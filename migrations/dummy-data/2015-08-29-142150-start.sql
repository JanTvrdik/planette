-- Adminer 4.2.1 MySQL dump

SET NAMES utf8;
SET time_zone = '+00:00';
SET foreign_key_checks = 0;
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

INSERT INTO `article` (`id`, `translation_id`, `created_date`, `updated_date`, `user_id`, `title`, `slug`, `content`, `language`, `views`, `document_state`) VALUES
  (1,	4,	'2014-10-28 10:19:14',	'2014-10-28 10:19:14',	3705,	'Dibi fluent insert',	'dibi-fluent-insert',	'**don\'t forget** for execute\n\n/--\n\n$dibi->insert(\'table\', $values)\n    ->execute(\\Dibi::IDENTIFIER);\n\n\\--',	'en',	0,	'public'),
  (2,	0,	'2014-10-28 18:21:20',	'2014-10-28 18:21:20',	3705,	'How to test exception call',	'how-to-test-exception-call',	'/--php\nAssert::exception(function () {\n	$this->userManager->addUser(\'user\',\'P455w0rd\');\n}, \'DuplicateEntryException\');\n\n--/',	'en',	0,	'public'),
  (3,	0,	'2014-10-28 10:29:42',	'2014-10-28 10:29:42',	3705,	'How to create custom validation rulles',	'how-to-create-custom-validation-rulles',	'Constants (DOMAIN, USER_IN_DOMAIN) contain name of static function, that call for validation.\n\nExample \"user in domain\", show us, how work with parameters. \n\n\n/--php\n\nclass DomainsRules\n{\n	const DOMAIN = \'DomainsRules::validateDomain\';\n	const USER_IN_DOMAIN = \'DomainsRules::validateUserInDomain\';\n\n	public static function validateDomain(\\Nette\\Forms\\IControl $control)\n	{\n		// dump($control->getValue());\n		// return TRUE or FALSE\n	}\n\n	public static function validateUserInDomain(\\Nette\\Forms\\IControl $control, $domain)\n	{\n		// dump($control->getValue());\n		// return TRUE or FALSE\n	}\n}\n\\--\n\n\n/--php\n\n$form->addText(\'domain\', \'Domain:\')\n			->addRule(DomainsRules::DOMAIN, \'fill domain in format domain.tld\');\n\n\n$form->addText(\'user\', \'User:\')\n			->addRule(DomainsRules::USER_IN_DOMAIN, \'user is not in domain nette.org\', \'nette.org\');\n\n\\--\n\n\n--czech \nKonstanta obsahuje název statické funkce co se má volat pro validaci.\n\nuser in domain ukazuje jak predavat a prijmat dalsi parametry',	'en',	0,	'public'),
  (4,	0,	'2014-10-28 10:35:36',	'2014-10-28 10:35:36',	3705,	'Form image and rules',	'form-image-and-rules',	'/--php\n\n$image = $form->addUpload(\'image\', \'Image:\');\n\n$image->addCondition(Form::FILLED)\n	->addRule(Form::IMAGE, \'Please select image file\');\n	->addRule(Form::MIME_TYPE, \'Please select jpeg image file\', \'image/jpeg\')\n	->addRule(Form::MAX_FILE_SIZE, \'Max allowed file size is 2 MB.\', \'20000\');\n\n\n// requre on condition option\nif (!$this->article) {\n	// we need image for main article\n	$image->addConditionOn($form[\'mainArticle\'], Form::EQUAL, TRUE) \n		->setRequired(\'Please select image.\');\n}\n\n\n\\--',	'en',	0,	'public'),
  (5,	0,	'2014-11-19 00:46:00',	'2014-11-19 00:46:00',	3705,	'How to AJAX response (with JSON)',	'how-to-ajax-response-with-json',	'/--php\n\n$this->sendJson($dataObject);\n\n\\--\n\nor\n\n/--php\n\n$this->sendResponse(new JsonResponse($myObject));\n\n\\--\n\nor use native nette channel\n\n/--php\n$this->payload->data = $data;\n$this->sendPayload();\n\\--\n\n\nor just redrow component\n\n/--php\nif ($this->isAjax()){\n     $this->redrawControl(\'datalist\');\n}\n\\--',	'en',	0,	'public'),
  (6,	1,	'2015-02-01 16:59:53',	'2015-02-01 16:59:53',	3705,	'How to use Texy in Latte template as a filter',	'how-to-use-texy-in-latte-template-as-a-filter',	'Install Texy via composer and register it as a service in *config.neon*\n\n/--neon [config.neon]\nservices\n	- Texy\n\\--\n\nRegister Texy as a latte filter in presenter\n\n/--php\n\n/**\n * @var \\Texy @inject\n */\npublic $texy;\n\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$template->addFilter(\'texy\', callback($this->texy, \'process\'));\n\n	return $template;\n}\n\n\\--\n\nand use it in latte file\n\n/--latte\n	{$article->content|noescape|texy}\n\\--',	'en',	0,	'public'),
  (7,	1,	'2014-11-19 17:52:09',	'2014-11-19 17:52:09',	3705,	'Jak použít Texy v šablonách',	'jak-pouzit-texy-v-sablonach',	'Instalujte Texy pomocí composeru a zaregistrujte ji jako službu v *config.neon*\n/--code neon [config.neon]\nservices\n	- Texy\n\\--\n\nRegistrujte Texy jako latte filter v presenteru\n\n/--code php\n\n/**\n * @var \\Texy @inject\n */\npublic $texy;\n\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$template->addFilter(\'texy\', callback($this->texy, \'process\'));\n\n	return $template;\n}\n\n\\--\n\na pak už jen používejte v latte\n\n/--code latte\n	{$article->content|noescape|texy}\n\\--',	'cs',	0,	'public'),
  (8,	2,	'2014-10-28 11:22:57',	'2014-10-28 11:22:57',	3705,	'How to change latte syntax for JavaScript',	'how-to-change-latte-syntax-for-javascript',	'/--latte\n<script n:syntax=\"double\">\n(function(i,s,o,g,r,a,m){i[\'GoogleAnalyticsObject\']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,\'script\',\'//www.google-analytics.com/analytics.js\',\'ga\');\n\nga(\'create\', \'UA-12345678-12\', \'domain.com\');\n{{if $user->isLoggedIn()}}ga(\'set\', \'dimension1\', {{$user->identity->username}});{{/if}}\nga(\'send\', \'pageview\');\n</script>\n\\--',	'en',	0,	'public'),
  (9,	0,	'2014-10-28 11:23:27',	'2014-10-28 11:23:27',	3705,	'latte simple foreach with {first} {last} macro',	'latte-simple-foreach-with-first-last-macro',	'/--latte\n{foreach $form->errors as $error}\n	{first}<ul>{/first}\n	<li class=\"error\">{$error}</li>\n	{last}</ul>{/last}\n{/foreach}\n\\--',	'en',	0,	'public'),
  (10,	0,	'2014-10-28 11:24:06',	'2014-10-28 11:24:06',	3705,	'Recursive delete folder',	'recursive-delete-folder',	'/--php\n\n$dirContent = Nette\\Utils\\Finder::find(\'*\')->from($directory)->childFirst();\nforeach ($dirContent as $file) {\n  if ($file->isDir())\n    @rmdir($file->getPathname());\n  else\n    @unlink($file->getPathname());\n}\n\n@unlink($directory);\n\n\\--',	'en',	0,	'public'),
  (12,	3,	'2014-10-28 11:27:11',	'2014-10-28 11:27:11',	3705,	'Connect Dibi as a service with tracy bar',	'connect-dibi-as-a-service-with-tracy-bar',	'config.neon\n/--neon\n\nparameters:\n	database:\n		host: localhost\n		username: root\n		password: ***\n		database: database_name\n		lazy: TRUE\n        profiler : TRUE\n\nservices:\n	connection:\n		class: DibiConnection(%database%)\n\n\\--\n\nor with extension\n\n/--neon\n# This will create service named \'dibi.connection\'.\n# Requires Nette Framework 2.2\n\nextensions:\n	dibi: Dibi\\Bridges\\Nette\\DibiExtension22\n\ndibi:\n	host: localhost\n	username: root\n	password: ***\n	database: database_name\n	lazy: TRUE\n\\--',	'en',	0,	'public'),
  (14,	0,	'2014-10-28 11:33:03',	'2014-10-28 11:33:03',	3705,	'Posílání emailů do tracy',	'posilani-emailu-do-tracy',	'Použijeme http://addons.nette.org/jandrabek/nette-mailpanel\n\nPomocí composeru nainstalujeme rozšíření \n\n`composer require jandrabek/nette-mailpanel`\n\n\na v *config.local.neon* přepíšeme defaultní mailer  \n\n/--neon\nservices:\n	nette.mailer: JanDrabek\\MailPanel\\SessionMailer\n\nnette:\n	debugger:\n		bar: [JanDrabek\\MailPanel\\MailPanel]\n\\--',	'cs',	0,	'public'),
  (15,	0,	'2014-10-28 11:36:56',	'2014-10-28 11:36:56',	3705,	'Examples of  macro \"n:class\" usage',	'examples-of-macro-n-class-usage',	'use `,` as class separator\n\n/--latte\n\n<header n:class=\"position-default, homepage, $query ? position-top\">\n	<h1>Nette Code Snippets</h1>\n</header>\n\n{* is same as: *}\n\n<header class=\"position-default homepage{if $query!=\'\'} position-top{/if}\">\n	<h1>Nette Code Snippets</h1>\n</header>\n\n\\--\n',	'en',	0,	'public'),
  (16,	0,	'2014-10-28 11:40:28',	'2014-10-28 11:40:28',	3705,	'Jak na lazy factory',	'jak-na-lazy-factory',	'automatické vytvoření lazy factory\n\n\nregistrujte v *config.neon*\n\n/--neon\n\n- SeoFactory\n\n\\--\n\nPro naši SEO třídu si vyrobíme interfaces s **anotací**\n\n*SEO.php*\n/--php \n\ninterface SeoFactory\n{\n	/** @return SEO */\n	function get();\n}\n\nclass SEO \n{\n...\n}\n\n\\--\n\na DI kontajner se už postará o vytvoření v tu pravou chvíli.\n',	'en',	0,	'public'),
  (17,	0,	'2014-10-28 11:46:33',	'2014-10-28 11:46:33',	3705,	'Auto factory na třídy',	'auto-factory-na-tridy',	'Chceme továrničku co nám bude vytvářet instance článku\n\nnaše třída pro článek:\n/--php\n\nclass Article\n{\n	private $db;\n\n	function __construct(PDO $db)\n	{\n		$this->db = $db;\n	}\n\n	function save()\n	{\n		$this->db->query(\"SELECT 1\");\n	}\n}\n\\--\n\nv config.neon zaregistrujeme \n\n/--neon\nservices:\n	- ArticleFactory\n\\--\n\na vytvoříme si interface s **anotací**\n\n/--php\n\ninterface ArticleFactory\n{\n	/**\n	 * @return Article\n	 */\n	function create();\n}\n\n\\--\n\n\na DI container za nás automaticky vygeneruje něco jako: \n\n/--php\nclass ArticleFactory\n{\n	private $db;\n\n\n	function __construct(PDO $db)\n	{\n		$this->db = $db;\n	}\n\n\n	public function create()\n	{\n		return new Article($this->db);\n	}\n\n}\n\\--\n\ntakže my už můžeme používat po injectnutí do presenteru articleFactory a její metodu create\n\n\n/--php\n\n$article = $this->articleFactory->create();\n$article->save();\n\n\\--\n\n',	'cs',	0,	'public'),
  (18,	0,	'2014-11-02 11:31:24',	'2014-11-02 11:31:24',	3705,	'Dvě instance jedné třídy s definicí primární',	'dve-instance-jedne-tridy-s-definici-primarni',	'Pokud chceme například dvě připojení k databázi, s tím že jedna je autowirovana (=bude předávána objektům kteří si o ní řeknou) u druhé je autowire zakázaný (vznikla by jinak chyba, že DI container neví kterou z nich má objektů předávat)\n\n/--neon\n\npdo: PDO(\'mysql:host=127.0.0.1;dbname=test\', \'test\',\'p4s5w0Rd\')\n	- App\\Model\\UserManager\n\ntestdb:\n	factory: PDO(\'mysql:host=127.0.0.1;dbname=testdb\', \'testdb\', \'p4s5w0Rd\')\n	setup:\n		- setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION)\n	autowired: no\n\\--',	'cs',	0,	'public'),
  (19,	0,	'2014-10-28 11:53:00',	'2014-10-28 11:53:00',	3705,	'Vlastní továrnička na třídu jako statická funkce',	'vlastni-tovarnicka-na-tridu-jako-staticka-funkce',	'config.neon\n/--neon\nservices:\n	- PdoFactory::create(\'mysql:host=localhost;dbname=test\')\n\\--\n\n\ndefinice továrničky\n\n/--php\nclass PdoFactory\n{\n	/**\n	 * @param $dsn\n	 * @return PDO\n	 */\n	static function create($dsn)\n	{\n		$name = \'xxx\';\n		$password = \'asd\';\n\n		return new PDO($dsn, $name, $password);\n	}\n}\n\\--',	'cs',	0,	'public'),
  (20,	5,	'2014-10-28 11:55:25',	'2014-10-28 11:55:25',	3705,	'Formulář a podmíněné tlačítko',	'formular-a-podminene-tlacitko',	'v definici formuláře\n/--php\n\nif (!empty($this->article)){\n	$form->addSubmit(\'send\', \'Edit article\');\n	$form->addSubmit(\'sendAndView\', \'Edit article and view\');\n} else {\n	$form->addSubmit(\'send\', \'Add article\');\n}\n\\--\n\nve zpracovani formu\n\n/--php\nif ($form[\'send\']->isSubmittedBy())\n{\n	// ...\n}\nif (isset($form[\'sendAndView\']) && $form[\'sendAndView\']->isSubmittedBy())\n{\n	// ...\n}\n\n\\--\n\n\nve vlastním vykreslování formuláře\n\n/--latte\n{ifset $form[sendAndView]}\n	{input sendAndView class => \"btn btn-secondary\"}\n{/ifset}\n\\--',	'cs',	0,	'public'),
  (21,	0,	'2014-10-28 12:11:40',	'2014-10-28 12:11:40',	3705,	'Různé zápisy v neonu',	'ruzne-zapisy-v-neonu',	'Předání pojmenované služby\n/--neon\nservices:\n	testdb: PDO(\'mysql:host=localhost;dbname=test\', \'test\',\'\') # named services\n	- Article(@testdb) # testdb is defined as service with name    \n\\--\n\n\nRozepsané volání vytvoření služby s nastavením public proměnné $db\n/--neon\nservices:\n	-\n		factory: App\\Presenter\\HomepagePresenter\n		setup:\n			- $db( stdClass() )\n\n	-\n		factory: App\\Presenter\\HomepagePresenter\n		setup:\n			- $db(@testdb) # used named service\n\n\\--\n\n\n\nRozepsaný zápis zkráceného `- ArticleFactory`\n/--neon\nservices:\n	-\n		implement: ArticleFactory\n		# factory: Article # is defined in @return anotation\n		# parameters: [a, b] \n\n\\--\n\n\nPřeskočení definování parametrů, které si DI kompilátor může získat sám pomocí autowire mechanismu \n/--neon\nservices:\n	- ArticleManager(..., ..., 123) # first ans second DI will autofill, third param we define\n\n\\--\n\n\nV konfiguraci můžeme volat i php funkce\n/--neon\nservices:\n	- AssetsCache( ::time() ) # return value from time() function\n\\--\n\n\nVypnutí autowired modu\n/--neon\n	pdo: PDO(\'mysql:host=localhost;dbname=test\', \'test\',\'\')\n	- App\\Model\\UserManager\n	- PdoFactory::create(\'mysql:host=localhost;dbname=test\')\n	testdb:\n		factory: PDO(\'mysql:host=127.0.0.1\', \'root\', \'xxx\')\n		setup:\n			- setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION)\n		autowired: no # <----  THIS\n\\--',	'cs',	0,	'public'),
  (22,	0,	'2014-11-02 11:34:40',	'2014-11-02 11:34:40',	3705,	'How to setup SimpleAuthenticator',	'how-to-setup-simpleauthenticator',	'with DI extension in *config.neon*\n\n/--neon\n\nnette:\n	security:\n		users:\n			john: p4ss\n			admin: P4S5w0rD@!\n\n\\--\n\n\nis the same as long version without using DI extension in *config.neon*\n/--neon\nservices:\n	- Nette\\Security\\SimpleAuthenticator({john:p4ss, admin: \'P4S5w0rD@!\'})\n\\--\n\n\n    ',	'en',	0,	'public'),
  (23,	0,	'2014-10-28 12:21:55',	'2014-10-28 12:21:55',	3705,	'Overwrite whole section in neon config',	'overwrite-whole-section-in-neon-config',	'If you use in *config.local.neon* exclamation mark after section name, mechanism overwrite all what was defined in *config*\n\n/--neon\n# config.local.neon\nnette:\n	session!:   # <-- there is exclamation mark\n    	autoStart: yes\n\n\\--\n\n\n\n/--neon\n# config.neon\nnette:\n	session:\n		expiration: 14 days\n\n\\--\n\nin result **is not** expiration parametr from main *config.neon* file',	'en',	0,	'public'),
  (24,	0,	'2014-10-28 12:23:25',	'2014-10-28 12:23:25',	3705,	'Simple way hot to setup basic router from config file',	'simple-way-hot-to-setup-basic-router-from-config-file',	'*config.neon*\n\n/--neon\nrouting:\n	routes:\n		<presenter>/<action>: Homepage:default\n        \n\\--',	'en',	0,	'public'),
  (26,	0,	'2014-10-28 12:24:38',	'2014-10-28 12:24:38',	3705,	'Možnosti zápisu rout pro Router',	'moznosti-zapisu-rout-pro-router',	'id je cislo\n/--php\n\n\n$router[] = new Route(\'<presenter>/<action>[/<id \\d+>]\', \'Homepage:default\');\n\n\\--\n\n\ncokoli i /\n/--php\n\n\n$router[] = new Route(\'<slug> .+\', \'Homepage:default\');\n\n\\--\n\n\ni to co je za ?\n/--php\n\n\n$router[] = new Route(\'login ? cmd=<action>\', \'Sign:in\');\n\n\\--\n\n\n/--php\n\n\n$router[] = new Route(\'<presenter>/<action>\', [\n	\'presenter\' => [\n    	Route::VALUE => \'Homepage\',\n    \n    ],\n    \'action\' => [\n    	Route::VALUE => \'default\',\n        Route::PATTERN => \'[a-z]+\',\n        Route::FILTER => [\n        	\'ahoj\' => \'xxx\'\n        ],\n        Route::FILTER_STRICT => TRUE,\n    ]\n]);\n\n\\--\n\n\n/--php\n$router[] = new Route(\'<presenter>/<action>\', [\n	\'presenter\' => [\n    	Route::VALUE => \'Homepage\',\n    \n    ],\n    \'action\' => [\n    	Route::VALUE => \'default\',\n        Route::FILTER_IN => function($val){\n        	return $val . \'123\'; // + RawUrlDecode\n        },\n        Route::FILTER_OUT => function($val){\n        	return substr( $val, 0, -3) \n        },\n        Route::FILTER_STRICT => TRUE,\n    ]\n]);\n\\--\n\n\n\n/--php\n$router[] = new Route(\'<presenter>/<action>\', [\n	NULL => [\n    	Route::FILTER_IN => function($params){\n        	dump($params) // zde de jde ziskat podle slug ze 3 tabulek\n            return $params;\n        },\n        Route::FILTER_OUT => function($params){\n        	dump($params)\n            return $params;\n        },\n    ],\n	\'presenter\' => [\n    	Route::VALUE => \'Homepage\',\n    \n    ],\n    \'action\' => [\n    	Route::VALUE => \'default\',\n        Route::FILTER_IN => function($val){\n        	return $val . \'123\'; // + RawUrlDecode\n        },\n        Route::FILTER_OUT => function($val){\n        	return substr( $val, 0, -3) \n        },\n        Route::FILTER_STRICT => TRUE,\n    ]\n]);\n\\--\n\n/--php\n$router[] = new Route(\'<? [0-9]{4}>/<presenter>/<action>\'); // cislo na zacatku se zahazuje\n\\--\n\n\n\n/--php\n$router[] = new Route(\'<id [\\d+]>[-<slug>]\', \'Homepage:default\');\n\\--\n',	'cs',	0,	'public'),
  (27,	0,	'2014-10-28 12:26:24',	'2014-10-28 12:26:24',	3705,	'Use persistent parameters in Presenters',	'use-persistent-parameters-in-presenters',	'/--php\n\nclass ProductPresenter extends Presenter\n{\n    /** @persistent */\n    public $lang;\n\n    ...\n    \n\\--',	'en',	0,	'public'),
  (28,	0,	'2014-10-28 12:33:35',	'2014-10-28 12:33:35',	3705,	'Jak na LIKE dotaz s Nette\\Database',	'jak-na-like-dotaz-s-nette-database',	'Jednoduchý zpusob je:\n\n/--php\n$db->table(\'table_name\')->where(\"neco LIKE ?\", \"%{$search}%\");\n\\--\n\n\nSpravně, ale:\n\n/--php\n$db->table(\'table_name\')->where(\'name LIKE ?\',new \\Nette\\Database\\SqlLiteral($db->getSupplementalDriver()->formatLike($search, 0)));\n\\--\n\nzroj: http://rjwebdesign.cz/blog/nette/20140826-jak-spravne-pouzit-like-v-nette-database',	'cs',	0,	'public'),
  (29,	0,	'2014-10-28 13:04:22',	'2014-10-28 13:04:22',	3705,	'Komplikovanější Router factory',	'komplikovanejsi-router-factory',	'/--php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\SimpleRouter;\n\n\n/**\n * Router factory.\n */\nclass RouterFactory\n{\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter()\n	{\n		$router = new RouteList();\n		$router[] = new Route(\'autocomplete[/<do>]\', function($id){\n\n		});\n		$router[] = new Route(\'login ? cmd=<action>\', \'Sign:in\');\n		$router[] = new Route(\'<? [0-9]{4}>/<presenter>/<action>\', [\n			NULL => [\n				Route::FILTER_IN => function($params) {\n					dump($params);\n					return $params;\n				},\n				Route::FILTER_OUT => function($params) {\n					dump($params);\n					return $params;\n				},\n			],\n			\'presenter\' => [\n				Route::VALUE => \'Homepage\',\n			],\n			\'action\' => [\n				Route::VALUE => \'default\',\n				Route::FILTER_IN => function($val){\n					return $val . \'123\';\n				},\n				Route::FILTER_OUT => function($val){\n					return substr($val, 0, -3);\n				},\n				Route::FILTER_STRICT => TRUE,\n\n			],\n		]);\n\n		//$router[] = new Route(\'<slug .+>\', \'Homepage:default\');\n		//$router[] = new Route(\'<presenter>/<action>[/<id \\d+>]\', \'Homepage:default\');\n		return $router;\n	}\n\n}\n\n\\--',	'cs',	0,	'public'),
  (34,	0,	'2014-10-27 18:03:16',	'2014-10-27 18:03:16',	3705,	'Jak na znovupouzitelne formulare',	'jak-na-znovupouzitelne-formulare',	'Nebudeme definovat formular v presenteru, ale pomoci DI si nechame injectnout pomocnou tovarni tridu ktere v metode *createLoginForm* ho vytvori a vrati nam ho  \n\n/--php [HomepagePresenter.php]\n\nclass HomepagePresenter extends BasePresenter\n{\n	/** @var \\FormFactory @inject */\n	public $formFactory;\n\n	function createComponentLoginForm()\n	{\n		$form = $this->formFactory->createLoginForm();\n		$form->onSuccess[] = function(){\n			$this->redirect(\'...\'); // zde uz staci jen nastavit kam presmerovat\n		};\n		return $form;\n	}\n    \n\\--\n\n**nezapomente** na vytvoreni service v sekce services v *config.neon*\n\n/--neon [config.neon]\n...\nservices\n	- FormFactory\n...\n\\--\n\na pak priblizne jak by mohla vypadat trida *FormFactory*\n\n\n/--php [FormFactory.php]\n\n<?php\n\nclass FormFactory\n{\n\n	function createLoginForm()\n	{\n		$form = new Nette\\Application\\UI\\Form;\n		$form->addSubmit(\'send\');\n		$form->onSuccess[] = function($form, $vals){\n			//$vals;\n            // zde zpracujete formular (bez finalniho redirectu jak jste zvykli) \n			// $form->addError(); // timhle se pripadne stopne dalsi volani onSuccess\n		};\n		return $form;\n	}\n\n}\n\n\\--',	'cs',	0,	'public'),
  (35,	0,	'2014-10-28 13:03:07',	'2014-10-28 13:03:07',	3705,	'Jak v Database pracovat s datumem případně s NOW()',	'jak-v-database-pracovat-s-datumem-pripadne-s-now',	'Pro where nebo insert/update lze použít\n\n/--php\n\n...->where(\"x = ?\", new \\DateTime()); \n\n\\--\n\n\ns použitím funkce `NOW()` je to komplikovanější\n\n/--php\n$db->table(\'table_name\')->get(1)->update(array(\'updated_at\'=>new \\Nette\\Database\\SqlLiteral(\'NOW()\')));\n\\--\n\nzroj: http://rjwebdesign.cz/blog/nette/20140826-jak-spravne-pouzit-like-v-nette-database\n',	'cs',	0,	'public'),
  (36,	2,	'2014-10-31 18:37:29',	'2014-10-31 18:37:29',	3705,	'Jak změnit latte syntaxi pro použití s JavaScriptem',	'jak-zmenit-latte-syntaxi-pro-pouziti-s-javascriptem',	'/--latte\n<script n:syntax=\"double\">\n(function(i,s,o,g,r,a,m){i[\'GoogleAnalyticsObject\']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,\'script\',\'//www.google-analytics.com/analytics.js\',\'ga\');\n\nga(\'create\', \'UA-12345678-12\', \'domain.com\');\n{{if $user->isLoggedIn()}}ga(\'set\', \'dimension1\', {{$user->identity->username}});{{/if}}\nga(\'send\', \'pageview\');\n</script>\n\\--',	'cs',	0,	'public'),
  (38,	3,	'2014-10-31 18:51:28',	'2014-10-31 18:51:28',	3705,	'Nastavení Dibi jako service s podporou tracy',	'nastaveni-dibi-jako-service-s-podporou-tracy',	'config.neon\n/--neon\n\nparameters:\n	database:\n		host: localhost\n		username: root\n		password: ***\n		database: database_name\n		lazy: TRUE\n        profiler : TRUE\n\nservices:\n	connection:\n		class: DibiConnection(%database%)\n\n\\--\n\nnebo pomocí extension\n\n/--neon\n# This will create service named \'dibi.connection\'.\n# Requires Nette Framework 2.2\n\nextensions:\n	dibi: Dibi\\Bridges\\Nette\\DibiExtension22\n\ndibi:\n	host: localhost\n	username: root\n	password: ***\n	database: database_name\n	lazy: TRUE\n\\--',	'cs',	0,	'public'),
  (39,	4,	'2015-01-18 18:22:53',	'2015-01-18 18:22:53',	3705,	'Dibi fluent insert',	'dibi-fluent-insert',	'**nezapomeňte** na execute\n\n/--php\n\n$dibi->insert(\'table\', $values)\n    ->execute(\\Dibi::IDENTIFIER);\n\n\\--',	'cs',	0,	'public'),
  (40,	6,	'2014-12-04 00:24:57',	'2014-12-04 00:24:57',	3705,	'Example with image',	'example-with-image',	'cesnek :) \n\n[* knowledgebase/qzfqfjarev.547f9a3a18673.jpg, 200x200, fill *]\n\nindian\n\n[* knowledgebase/74xp1ynlsl.547f9ae5cd461.jpg, 200x200, exact *]\n\nsnehububu\n\n[* knowledgebase/9gncuugy41.547f9b5889fb4.jpg, 200x200, exact *]',	'en',	0,	'public'),
  (41,	5,	'2014-11-05 20:31:41',	'2014-11-05 20:31:41',	3705,	'Formulář a podmíněné tlačítko (en)',	'formular-a-podminene-tlacitko-en',	'v definici formuláře\n\n/--php\n\nif (!empty($this->article)){\n	$form->addSubmit(\'send\', \'Edit article\');\n	$form->addSubmit(\'sendAndView\', \'Edit article and view\');\n} else {\n	$form->addSubmit(\'send\', \'Add article\');\n}\n\\--\n\nve zpracovani formu\n\n/--php\nif ($form[\'send\']->isSubmittedBy())\n{\n	// ...\n}\nif (isset($form[\'sendAndView\']) && $form[\'sendAndView\']->isSubmittedBy())\n{\n	// ...\n}\n\n\\--\n\n\nve vlastním vykreslování formuláře\n\n/--latte\n{ifset $form[sendAndView]}\n	{input sendAndView class => \"btn btn-secondary\"}\n{/ifset}\n\\--',	'en',	0,	'public'),
  (42,	0,	'2014-11-08 23:09:50',	'2014-11-08 23:09:50',	3705,	'Error presenter z modulu',	'error-presenter-z-modulu',	'Lze použít dvoujtečkový zápis pro definici modulu\n\n/--neon\nnette:\n	application:\n		errorPresenter: \"Front:Error\"\n        \n\\--',	'cs',	0,	'public'),
  (43,	0,	'2014-11-10 10:38:30',	'2014-11-10 10:38:30',	3705,	'Jednoduché stránkování záznamy (TODO)',	'jednoduche-strankovani-zaznamy-todo',	'Potřebujeme nějakou třídu ArticleModel co nám bude vracet kolekci (nefetchnutá data) a jejich celkový počet.\n\n/--php\n\npublic function renderList($page = 1)\n{\n	$this->page = $page;\n\n	$paginator = new Paginator();\n	$paginator->setItemsPerPage(10);\n	$paginator->setPage($this->page);\n	$count = $this->articleModel->getCount();\n	$paginator->setItemCount($count);\n\n	if ($count > $paginator->itemsPerPage && !$paginator->last) {\n		$this->template->page = $page;\n		$this->template->showMoreButton = TRUE;\n	} else {\n		$this->template->showMoreButton = FALSE;\n	}\n\n	$this->template->articleList = $this->articleManager->find()\n		->limit($paginator->itemsPerPage, $paginator->offset)\n		->fetchAll();\n\n	// pro ajaxove dokreslovani\n	if ($this->isAjax()){\n		$this->redrawControl(\'articleList\');\n		$this->redrawControl(\'articleListButton\');\n	}\n}\n\n\\--',	'cs',	0,	'public'),
  (44,	0,	'2014-11-10 16:41:32',	'2014-11-10 16:41:32',	3705,	'Ajax snippet s append místo replace (TODO)',	'ajax-snippet-s-append-misto-replace-todo',	'/--latte\n\n{* FUNGUJE *}\n<div n:snippet=\"timelineList\" data-ajax-append data-ajax-append-animate=\"fade\">\n	xxx\n</div>\n\n{* nefunguje*}\n{snippet timelineList div , data-ajax-append, data-ajax-append-animate=\"fade\"}\n	xxx\n{/snippet}\n\n\n\\--',	'cs',	0,	'public'),
  (57,	0,	'2015-04-24 20:36:09',	'2015-04-24 20:36:09',	3705,	'Jak zapnout Tracy na produkčním serveru pouze pro mě',	'jak-zapnout-tracy-na-produkcnim-serveru-pouze-pro-me',	'/--php\n\n\n\n\\--',	'cs',	0,	'public'),
  (58,	0,	'2015-04-05 16:38:23',	'2015-04-05 16:38:23',	3705,	'jak řešit různé count pomocí Kdyby Translator',	'jak-resit-ruzne-count-pomoci-kdyby-translator',	'@Kdyby Translation pro #nettefw:\n\n{0} žádný popis.|{1} 1 popis.|[2,4] %count% popisy.|[5,Inf] %count% popisů.',	'cs',	0,	'public'),
  (59,	0,	'2015-04-07 11:07:55',	'2015-04-07 11:07:55',	3705,	'Stránkování - komplexní řešení',	'strankovani-komplexni-reseni',	'hotove reseni:\n\n \"pvy/nette-visual-paginator\":https://github.com/pvy/nette-visual-paginator\n\n \"zeleznypa/jao-nette-visual-paginator\":https://github.com/zeleznypa/jao-nette-visual-paginator\n\n \"iPublikuj/visual-paginator\":https://github.com/iPublikuj/visual-paginator\n\nPokud chces jenom tridu pro ulehceni prace, tak doporucuju pouzit primo \"Nette\\Utils\\Paginator\":http://doc.nette.org/cs/2.3/pagination',	'cs',	0,	'public'),
  (60,	0,	'2015-04-24 19:24:37',	'2015-04-24 19:24:37',	3705,	'Formuláře jako komponenty',	'formulare-jako-komponenty',	'Vytvářet znovupoužitelné formuláře je snadné, máte na výběr několik různých způsobů a každý se hodí na jiný případ.\n\n\nTovárna na `UI\\Form` .{toc: Factory}\n***\n\nUděláme si factory třídu, kterou zaregistrujeme do [DI Containeru |doc:dependency-injection#toc-di-kontejner-a-sluzby] a použijeme v našich presenterech k vytváření instancí formulářů.\n\n/--php\nuse Nette\\Application\\UI;\n\nclass CategoryForm extends Nette\\Object\n{\n	private $database;\n\n	public function __construct(Nette\\Database\\Connection $database)\n	{\n		$this->database = $database;\n	}\n\n	public function create()\n	{\n		$form = new UI\\Form;\n		// mohu použít $this->database\n\n		$form->addSubmit(\'send\', \'Odeslat\');\n		$form->onSuccess[] = $this->processForm;\n\n		return $form;\n	}\n\n	public function processForm($form)\n	{\n		// mohu použít $this->database\n		// zpracovani formulare\n	}\n}\n\\--\n\nZaregistrujeme továrnu jako službu\n\n/--code neon\nservices:\n	- CategoryForm\n\\--\n\nInjectneme si ho do presenteru\n\n/--php\nuse Nette\\Application\\UI;\n\nclass MyPresenter extends BasePresenter\n{\n	/** @var \\CategoryForm @inject */\n	public $categoryFormFactory;\n\n	protected function createComponentCategoryForm()\n	{\n		$form = $this->categoryFormFactory->create();\n		$form->onSuccess[] = function (UI\\Form $form) {\n			$this->redirect(\'this\');\n		};\n\n		return $form;\n	}\n}\n\\--\n\n\n.[tip]\nAby byla komponenta skutečně znovupoužitelná, je nejlepší přesměrování po úspěšném odeslání mít až v konkrétní továrničce. Takto mohu komponentu použít na více místech a na každém můžu bez odporného ifování přesměrovat vždy jinam.\n\n\n\nFormulář v `UI\\Control` a generovaná továrnička .{toc: UI\\Control}\n***\n\nPokud chceme, aby se formulář renderoval specifickým způsobem a opět ho chceme použít na více místech aplikace, je vhodné obalit ho do `UI\\Control`, který si nese vlastní šablonu.\n\n\n/--php\nclass CategoryForm extends UI\\Control\n{\n	private $database;\n\n	public $onCategorySave;\n\n	public function __construct(Nette\\Database\\Connection $database)\n	{\n		parent::__construct();\n		$this->database = $database;\n	}\n\n	protected function createComponentForm()\n	{\n		$form = new UI\\Form;\n		// mohu použít $this->database\n\n		$form->addSubmit(\'send\', \'Odeslat\');\n		$form->onSuccess[] = $this->processForm;\n\n		return $form;\n	}\n\n	public function processForm($form)\n	{\n		// mohu použít $this->database\n		// zpracování formuláře, např. změním údaje upravované kategorie\n		// $category je nějaký řádek tabulky (entita), kterou zpracováváme\n		$this->onCategorySave($this, $category);\n	}\n}\n\n/** rozhranní pro generovanou továrničku */\ninterface ICategoryFormFactory\n{\n	/** @return \\CategoryForm */\n	function create();\n}\n\\--\n\nSamozřejmostí je použití [generovaných továrniček |create-components-with-autowiring], díky kterým opět můžeme komponentu vytvářet pomocí DI Containeru a o předávání služeb se nestaráme.\n\n\nZaregistrujeme rozhranní pro generovanou továrničku jako službu\n\n/--code neon\nfactories:\n	- ICategoryFormFactory\n\\--\n\nToto rozhraní si necháme injectnout do presenteru.\n\n/--php\nuse Nette\\Application\\UI;\n\nclass MyPresenter extends BasePresenter\n{\n	/** @var \\ICategoryFormFactory @inject */\n	public $categoryFormFactory;\n\n	protected function createComponentCategoryForm()\n	{\n		$control = $this->categoryFormFactory->create();\n		$control->onCategorySave[] = function(CategoryControl $control, $category) {\n			$this->redirect(\'this\');\n			// nebo například přesměrujeme na detail dané kategorie\n			// $this->redirect(\'detail\', array(\'id\' => $category->id));\n		}\n\n		return $control;\n	}\n}\n\\--\n\n\n\n.[note]\nJako bonus je možné velice snadno využít signály na pokročilou ajaxovou komunikaci a donačítání informací do formuláře (například napovídání).\n',	'cs',	0,	'public'),
  (61,	0,	'2015-04-24 19:25:59',	'2015-04-24 19:25:59',	3705,	'CMS a frameworky nad Nette',	'cms-a-frameworky-nad-nette',	'\n.[perex]\nNette Framework umožňuje příjemnou tvorbu vlastního frameworku či CMS, které dalším způsobem obohacují a rozšiřují jeho použitelnost.\n\nTato díla jsou obvykle volně šiřitelná, proto mohou poskytnout podobné usnadnění práce jako Nette samotné.\n\n\nCMS\n===\n\n|---\n| Název | Autor | Demo | Zdroj | Fórum | Rok* | verze Nette | DB Layer\n|---\n| **\"Flame:CMS\":http://projects.jsifalda.name/flame/** | [sifik|user:5153] | [demo|http://flame.jsifalda.name/] | [github|https://github.com/flame-cms/cms] | -- | 2012 | dev-master | Doctrine 2 ORM\n| **Moe\'s CMS** | [davidM|user:2459] | [demo|http://demo.moes.cz/] | [github|https://github.com/davidmoravek/moes-cms] | [vlákno|http://forum.nette.org/cs/10190-moe-s-cms-redakcni-system-postaveny-na-nette] | 2012 | 2.0-dev | Doctrine 2 ORM\n| **NanoCMS** | [Droid|user:3772] | [demo|http://www.gnip.cz/nanocms/www/] | [download|http://www.gnip.cz/nanocms/www/nanocms.zip], [github|https://github.com/Ginny/NanoCMS] | [vlákno|http://forum.nette.org/cs/7700-nanocms-nette-example-dynamickeho-webu] | 2011 | 2.0-dev | Nette\\Database\n| **\"nPress\":http://www.npress.info/** | [Pavel Zbytovský|user:136] | [demo|http://demo.npress.info/] | [download|https://github.com/downloads/zbycz/npress/npress-v0.5-rc.zip], [github|https://github.com/zbycz/npress] | [vlákno|http://forum.nette.org/cs/9973-npress-dalsi-cms-na-nette] | 2012 | 2.0 | dibi\n| **\"CoolMS\":http://coolms.slamecka.cz/** | [Ondřej Slámečka|user:2604] | [demo|http://coolms.slamecka.cz/] | [github|https://github.com/OndrejSlamecka/CoolMS] | [vlákno|http://forum.nette.org/cs/9190-coolms-web-content-management-system-zalozeny-na-nette] | 2011 | 2.0 | Nette\\Database\n| **\"Venne:CMS\":https://github.com/Venne/cms-module**| [pepakriz|user:2465] | [demo|http://demo.venne.cz/] | [github|https://github.com/Venne/cms-module]| [vlákno|http://forum.nette.org/cs/8154-venne-cms-volne-cms-pro-nette] | 2012 | 2.0-dev | Doctrine 2 ORM\n| **\"WebCMS2\":https://github.com/ufik/WebCMS2**| [Tomas Voslar] | [demo|http://demo.webcook.cz/] | [github|https://github.com/ufik/WebCMS2]| -- | 2014 | 2.0.* | Doctrine 2 ORM\n\n\n\nFrameworky\n===\n\n|---\n| Název | Autor | Zdroj | Fórum | Rok* | verze Nette | DB Layer\n|---\n| **\"Flame\":http://projects.jsifalda.name/flame/** | [sifik|user:5153] | [github|https://github.com/flame-org/Framework] | - | 2012 | 2.1-dev | Doctrine 2 ORM\n| **\"Nella\":http://nellafw.org/** | [Patrik Votoček|user:1639] | [github|https://github.com/nella/framework] | - | 2006 | 2.0 | Doctrine 2 ORM\n| **Neuron** | [HonzaMarek|user:516] |[github|https://github.com/janmarek/Neuron] | - | 2010 | ? | Doctrine\n| **\"Lohini\":http://lohini.net** | [Lopo|user:2108] | [github|https://github.com/Lohini/framework] | - | 2010 | 2.0-dev | Doctrine\n| **\"Venne:FW\":https://github.com/Venne/framework**| [pepakriz|user:2465] | [github|https://github.com/Venne/framework] | -- | 2012 | 2.0-dev | --\n\n\n\nBalíky rozšíření\n=====\n\n|---\n| Název | Maintainer | Zdroj | Fórum\n|---\n| **[Kdyby](http://kdyby.org/)** | [Filip Procházka|user:2118] | [github|https://github.com/Kdyby] | [vlastní fórum](https://help.kdyby.org/)\n| **[Nextras](http://nextras.cz/)** | [Hrach|user:449], [Jan Tvrdík|user:1657] | [github|https://github.com/nextras] | -\n| **[Zenify](https://github.com/zenify)** | [Tomáš Votruba|user:3194] | [github|https://github.com/zenify] | -\n\n',	'cs',	0,	'public'),
  (62,	0,	'2015-04-24 19:27:50',	'2015-04-24 19:27:50',	2118,	'Co je Dependency Injection?',	'co-je-dependency-injection',	'.[perex]\nDependency Injection (=injektování/vkládání/předání závislostí) je o tom, že každé třídě předáme to, co potřebuje k existenci.\n\n/--php\nclass Sluzba\n{\n	public function __construct(Sluzba2 $sluzba2, ISluzba3 $sluzba3)\n	{\n		$this->sluzba2 = $sluzba2;\n		$this->sluzba3 = $sluzba3;\n	}\n\n\n	public function dance()\n	{\n		if (!$this->iCanDance) {\n			$this->sluzba2->teachDance($this);\n		}\n\n		$this->sluzba3->danceWith($this);\n	}\n}\n\\--\n\nMísto toho, aby je skrytě vyhledávala ve svých metodách\n\n/--php\nclass Sluzba\n{\n\n	public function dance()\n	{\n		if (!$this->iCanDance) {\n			$sluzba2 = Nette\\Environment::getService(\'Sluzba2\');\n			$sluzba2->teachDance($this);\n		}\n\n		$sluzba3 = Nette\\Environment::getService(\'ISluzba3\');\n		$sluzba3->danceWith($this);\n	}\n\n}\n\\--\n\n- docílíme tím *větší přehlednosti*\n- *ztratíme magické schované závislosti*, budeme jasně vědět, že když chceme používat `Sluzba` tak jí musíme předat `Sluzba2` a `ISluzba3`, jinak nebude fungovat\n- *lépe se to testuje*, můžeme podstrčit jiné instance, které budou kontrolovat co se kam předává (mockování)\n- můžeme *použít tu samou třídu na více věcí*, jednou jí předáme `Sluzba10 implements ISluzba3` a podruhé `Sluzba50 implements ISluzba3`, bez toho aby jsme museli nějak ovlivňovat \"globální prostředí\" a zaneřádili container (serviceLocator)\n- ...\n\nS tím, že jí závislosti můžeme předat různými způsoby (konstruktor, metoda, vlastnost, ..). A k tomu nám dopomáhej [Dependency Injection Container|doc:/cs/dependency-injection], který se přímo stará o to, že třídám se předá to co potřebují. Na nás je DIC nakonfigurovat tak, aby věděl, co má čemu předat a my pak nemusíme psát ten kód, protože ho za nás automatizovaně vykoná, podle naší konfigurace. Navíc pak můžeme různě služby zase vyměňovat, ...\n\nA je to vůbec takové hezčí a voňavější OOP :)\n	',	'cs',	0,	'public'),
  (63,	0,	'2015-04-24 19:28:59',	'2015-04-24 19:28:59',	2118,	'Dědičnost vs kompozice',	'dedicnost-vs-kompozice',	'.[perex]\nDovolil bych si na krátké ukázce kódu srovnat klasické dědění tříd a kompozici, za využití \"Nette\\ComponentModel\":http://api.nette.org/2.0/namespace-Nette.ComponentModel.html. Ukázky kódu nejsou identické, jde jen o demonstraci síly kompozice.\n\n\n\nDědičnost\n---------\n\n/--php\nclass PersonForm extends Nette\\Application\\UI\\Form\n{\n	public function __construct()\n	{\n		parent::__construct();\n\n		$this->addText(\'name\', \'Jméno\');\n		$this->addSubmit(\'submit\', \'Odeslat\');\n	}\n}\n\nclass PersonWithAddressForm extends PersonForm\n{\n	public function __construct()\n	{\n		parent::__construct();\n\n		$this->addText(\'city\', \'Město\');\n		$this->addText(\'street\', \'Ulice\');\n	}\n}\n\\--\n\n\n\nKompozice\n---------\n\n/--php\nclass PersonContainer extends Nette\\Forms\\Container\n{\n	public function __construct()\n	{\n		parent::__construct();\n\n		$this->addText(\'name\', \'Jméno\');\n		$this->addText(\'surname\', \'Příjmení\');\n	}\n}\n\nclass AddressContainer extends Nette\\Forms\\Container\n{\n	public function __construct()\n	{\n		parent::__construct();\n\n		$this->addText(\'city\', \'Město\');\n		$this->addText(\'street\', \'Ulice\');\n	}\n}\n\n\nclass MyPresenter extends BasePresenter\n{\n	protected function createComponentPersonWithAddressForm()\n	{\n		$form = new Nette\\Application\\UI\\Form;\n		$form[\'user\'] = new PersonContainer();\n		$form[\'user\'][\'address\'] = new AddressContainer();\n		$form[\'user\'][\'correspondence\'] = new AddressContainer();\n		$form[\'user\'][\'billing\'] = new AddressContainer();\n\n		$form->addSubmit(\'submit\', \'Odeslat\');\n		$form->onSuccess[] = function () {};\n\n		return $form;\n	}\n}\n\\--\n',	'cs',	0,	'public'),
  (64,	0,	'2015-04-24 19:34:49',	'2015-04-24 19:34:49',	3328,	'Dynamické snippety',	'dynamicke-snippety',	'Poměrně často při vývoji aplikací vyvstává potřeba provádět AJAXové operace například nad jednotlivými řádky tabulky či položkami seznamu. Pro příklad si můžeme zvolit výpis článků, přičemž u každého z nich umožníme přihlášenému uživateli zvolit hodnocení \"líbí/nelíbí\". Kód presenteru a odpovídající šablony bez AJAXu bude vypadat přibližně následovně (uvádím nejdůležitější výseky, kód počítá s existencí služby pro značení si hodnocení a získáním kolekce článků - konkrétní implementace není pro účely tohoto návodu důležitá):\n\n/--php\npublic function handleLike($articleId)\n{\n	$this->ratingService->saveLike($articleId, $this->user->id);\n	$this->redirect(\'this\');\n}\n\npublic function handleUnlike($articleId)\n{\n	$this->ratingService->removeLike($articleId, $this->user->id);\n	$this->redirect(\'this\');\n}\n\\--\n\nŠablona:\n\n/--html\n<article n:foreach=\"$articles as $article\">\n	<h2>{$article->title}</h2>\n	<div class=\"content\">{$article->content}</div>\n	{if !$article->liked}\n		<a n:href=\"like! $article->id\" class=ajax>to se mi líbí</a>\n	{else}\n		<a n:href=\"unlike! $article->id\" class=ajax>už se mi to nelíbí</a>\n	{/if}\n</article>\n\\--\n\nAjaxizace\n==========\n\nPojďme nyní tuto jednoduchou aplikaci vybavit AJAXem. Změna hodnocení článku není natolik důležitá, aby muselo dojít k přesměrování, a proto by ideálně měla probíhat AJAXem na pozadí. Využijeme [obslužného skriptu z doplňků | addons:cs/jquery-ajax] s obvyklou konvencí, že AJAXové odkazy mají CSS třídu `ajax`.\n\nNicméně jak na to konkrétně? Nette nabízí 2 cesty: cestu tzv. dynamických snippetů a cestu komponent. Obě dvě mají svá pro a proti, a proto si je ukážeme jednu po druhé.\n\nCesta dynamických snippetů\n==========\n\nDynamický snippet znamená v terminologii Latte specifický případ užití makra `{snippet}`, kdy je v názvu snippetu použita proměnná. Takový snippet se nemůže v šabloně nalézat jen tak kdekoliv - musí být obalen statickým snippetem, tj. obyčejným. Naši šablonu bychom mohli upravit následovně.\n\n/--html\n{snippet articlesContainer}\n	<article n:foreach=\"$articles as $article\">\n		<h2>{$article->title}</h2>\n		<div class=\"content\">{$article->content}</div>\n		{snippet article-$article->id}\n			{if !$article->liked}\n				<a n:href=\"like! $article->id\" class=ajax>to se mi líbí</a>\n			{else}\n				<a n:href=\"unlike! $article->id\" class=ajax>už se mi to nelíbí</a>\n			{/if}\n		{/snippet}\n	</article>\n{/snippet}\n\\--\n\nKaždý článek nyní definuje jeden snippet, který má v názvu ID článku. Všechny tyto snippety jsou pak dohromady zabalené jedním snippetem s názvem `articlesContainer`. Pokud bychom tento obalující snippet opomněli, Latte nás na to upozorní výjimkou.\n\nZbývá nám doplnit do presenteru invalidaci - stačí zinvalidovat statickou obálku.\n\n/--php\npublic function handleLike($articleId)\n{\n	$this->ratingService->saveLike($articleId, $this->user->id);\n	if ($this->isAjax()) {\n		$this->invalidateControl(\'articlesContainer\');\n		// $this->invalidateControl(\'article-\' . $articleId); -- není potřeba\n	} else {\n		$this->redirect(\'this\');\n	}\n}\n\\--\n\nNápodobně upravíme i sesterskou metodu `handleUnlike()`, a AJAX je funkční!\n\nŘešení má však jednu stinnou stránku. Pokud bychom více zkoumali, jak AJAXový požadavek probíhá, zjistíme, že ačkoliv navenek se aplikace tváří úsporně (vrátí pouze jeden jediný snippet pro daný článek), ve skutečnosti na serveru vykreslila snippety všechny. Kýžený snippet nám umístila do payloadu, a ostatní zahodila (zcela zbytečně je tedy také získala z databáze).\n\nNette 2.0.x obsahuje bug, který způsobuje, že se snippety nezahodí, ale všechny se odešlou do prohlížeče. .[caution]\n\nNette 2.0.x ignoruje snippety v šablonách volaných přes makro include a podobné. .[caution]\n\nAbychom tento proces zoptimalizovali, budeme muset zasáhnout tam, kde si do šablony předáváme kolekci `$articles` (dejme tomu v metodě `renderDefault()`). Využijeme faktu, že zpracování signálů probíhá před metodami `render<Something>`:\n\n/--php\npublic function handleLike($articleId)\n{\n	...\n	if ($this->isAjax()) {\n		...\n		$this->template->articles = array(\n			$this->connection->table(\'articles\')->get($articleId)\n		);\n	} else {\n		...\n}\n\npublic function renderDefault()\n{\n	if (!isset($this->template->articles)) {\n		$this->template->articles = $this->connection->table(\'articles\');\n	}\n}\n\\--\n\nNyní se při zpracování signálu do šablony předá místo kolekce se všemi články jen pole s jediným článkem - tím, který chceme vykreslit a odeslat v payloadu do prohlížeče. `{foreach}` tedy proběhne jen jednou a žádné snippety navíc se nevykreslí.\n\nCesta komponent\n==========\n\nÚplně jiný způsob řešení se dynamickým snippetům vyhne. Trik spočívá v přenesení celé logiky do zvláštní komponenty - o zadávání hodnocení se nám od teď nebude starat presenter, ale vyhrazená `LikeControl`. Třída bude vypadat následovně (kromě toho bude obsahovat i metody `render`, `handleUnlike` atd.):\n\n/--php\nclass LikeControl extends Nette\\Application\\UI\\Control\n{\n	private $article;\n\n	public function __construct($article)\n	{\n		$this->article = $article;\n	}\n\n	public function handleLike()\n	{\n		$this->ratingService->saveLike($this->article->, $this->presenter->user->id);\n		if ($this->presenter->isAjax()) {\n			$this->invalidateControl();\n		} else {\n			$this->presenter->redirect(\'this\');\n		}\n	}\n}\n\\--\n\nŠablona komponenty:\n\n/--html\n{snippet}\n	{if !$article->liked}\n		<a n:href=\"like!\" class=ajax>to se mi líbí</a>\n	{else}\n		<a n:href=\"unlike!\" class=ajax>už se mi to nelíbí</a>\n	{/if}\n{/snippet}\n\\--\n\nSamozřejmě se nám změní šablona view a do presenteru budeme muset doplnit továrničku. Protože komponentu vytvoříme tolikrát, kolik z databáze získáme článků, využijeme k jejímu \"rozmnožení\" třídu [api:Nette\\Application\\UI\\Multiplier].\n\n/--php\nprotected function createComponentLikeControl()\n{\n	$articles = $this->connection->table(\'articles\');\n	return new Nette\\Application\\UI\\Multiplier(function ($articleId) use ($articles) {\n		return new LikeControl($articles[$articleId]);\n	});\n}\n\\--\n\nŠablona view se zmenší na nezbytné minimum (a zcela prosté snippetů!):\n\n/--html\n<article n:foreach=\"$articles as $article\">\n	<h2>{$article->title}</h2>\n	<div class=\"content\">{$article->content}</div>\n	{control likeControl-$article->id}\n</article>\n\\--\n\nMáme téměř hotovo: aplikace nyní bude fungovat AJAXově. I zde nás čeká aplikaci optimalizovat, protože vzhledem k použití `Nette\\Database` se při zpracování signálu zbytečně načtou všechny články z databáze namísto jednoho. Výhodou však je, že nedojde k jejich vykreslování, protože se vyrenderuje skutečně jen naše komponenta.\n\nPro a proti\n==========\n\n|----------------------------\n| | Cesta dynamických snippetů | Cesta komponent | |\n|----------------------------\n|* zápis | rychlejší | pomalejší (třeba vytvořit komponentu) |\n|* invalidace | složitější | jednodušší |\n|* výkon | zbytečně se renderují všechny \"řádky\" | renderuje se jen 1 \"řádek\" |\n|* znovupoužitelnost | ne | ano |',	'cs',	0,	'public'),
  (65,	0,	'2015-04-24 19:40:42',	'2015-04-24 19:40:42',	3328,	'Dynamické skrývání prvků ve formuláři',	'dynamicke-skryvani-prvku-ve-formulari',	'.[perex]\nChcete zobrazit políčka pro zadání adresy pouze, pokud chce uživatel zaslat zboží poštou? Žádný problém :).\n\nMetody `addCondition()` & `toggle()`\n-------------------\n\nKlíčem k triku s dynamickým zobrazováním políček je dvojice metod `addCondition()` & `toggle()`. Příklad z perexu by s jejich využitím mohl vypadat například takto:\n\n/--php\n$form->addCheckbox(\'mail_me\')\n	->addCondition($form::EQUAL, TRUE)\n		->toggle();\n\n$form->addText(\'city\');\n$form->addText(\'street\');\n$form->addText(\'zipcode\');\n\\--\n\nMetoda `addCondition()` umí přijímat stejné argumenty jako základní validační metoda `addRule()`, kromě toho, že nepodporuje žádnou chybovou hlášku. V ukázkovém kódu výše tedy volání doslova znamená \"pokud je tento prvek zaškrtnutý\". Metoda `toggle()` může vždy následovat až po volání `addCondition()`.\n\nNaše ukázka je však zatím nekompletní, metoda `toggle()` totiž vyžaduje argument: měla by jím být hodnota `id` atributu ve výsledném HTML kódu - element s tímto IDčkem pak bude dynamicky odhalen/skryt právě v závislosti na podmínce definované v `addCondition()`.\n\nJak získat ID pro `toggle()`\n-------------------\n\nVypadá to, že formulář budeme muset vyrenderovat manuálně, pomocí maker `{form}`, `{label}` a `{input}`, resp. `n:name`. V šabloně bychom pak mohli zapsat třeba takovýto kód:\n\n/--html\n<div id=\"address-container\">\n	{label city /} {input city}<br>\n	{label street /} {input street}<br>\n	{label zipcode /} {input zipcode}\n</div>\n\\--\n\nA volání v definice formuláře bychom doplnili následovně:\n\n/--php\n$form->addCheckbox(\'mail_me\')\n	->addCondition($form::EQUAL, TRUE)\n		->toggle(\'address-container\');\n\\--\n\nA je to, pokud máme v šabloně přilinkovaný soubor `netteForms.js`, políčka se budou ihned dynamicky objevovat v závislosti na zaškrtnutí checkboxu.\n\nJak se vyhnout manuálnímu renderování\n-------------------\n\nNutnost manuálně vykreslovat formulář může být často velmi otravná - například pokud máte v administraci spoustu velmi podobných formulářů. Pokud používáte `DefaultFormRenderer`, umí naštěstí framework podat pomocnou ruku. Stačí totiž prvkům nastavit zvláštní option `id`, která bude ve výsledku vykreslena jako ID atribut elementu obalujícího jak `<label>`, tak `<input>`, tedy přesně to, co potřebujeme. V praxi vypadá použití následovně:\n\n/--php\n$form->addCheckbox(\'mail_me\')\n	->addCondition($form::EQUAL, TRUE)\n		->toggle(\'address-city\')\n		->toggle(\'address-street\')\n		->toggle(\'address-zipcode\');\n\n$form->addText(\'city\')\n	->setOption(\'id\', \'address-city\');\n$form->addText(\'street\')\n	->setOption(\'id\', \'address-street\');\n$form->addText(\'zipcode\')\n	->setOption(\'id\', \'address-zipcode\');\n\\--\n\n.[note]\nProč jsme nemohli všem prvkům nastavit stejnou option `id` a zjednodušit si tak volání `toggle`? V HTML správně nesmí být více prvků se stejným ID. Javascript by se pak s takovou situací špatně vyrovnával.\n\nJe také vhodné zmínit, že metoda `toggle()` má druhý nepovinný parametr, kterým lze obrátit její chování. Pokud bychom zavolali `->toggle(\'address-city\', FALSE)`, políčko pro zadání města by se naopak zobrazilo pouze tehdy, pokud by checkbox zaškrtnutý nebyl.\n\n.[warning]\nMožná jste někde zahlédli metodu `setHtmlId`, kterou lze libovolnému formulářovému prvku nastavit ID. Ta se však pro naše účely nehodí, protože se nijak nedotýká odpovídajícího `<label>` - popisek by zůstal viditelný.\n\nJak přidat animaci\n-------------------\n\nVýchozí implementace `toggle()` v prohlížeči využívá pouhého nastavení CSS vlastnosti `display: none`, s čímž žádnou velkou parádu neuděláme. Přidání animace však není problém: stačí v Javascriptu přepsat metodu `Nette.toggle` vlastním řešením. S využitím jQuery pak třeba můžeme políčka pro adresu nechat přirolovat:\n\n/--js\nNette.toggle = function (id, visible) {\n	var el = $(\'#\' + id);\n	if (visible) {\n		el.slideDown();\n	} else {\n		el.slideUp();\n	}\n};\n\\--',	'cs',	0,	'public'),
  (66,	0,	'2015-04-24 19:38:02',	'2015-04-24 19:38:02',	3328,	'Multiplier',	'multiplier',	'Nástroj na dynamickou tvorbu komponent .[perex]\n\nVyjděme od typického příkladu: mějme seznam zboží v eshopu, přičemž u každého budeme chtít vypsat formulář pro přidání zboží do košíku. Jednou z možných variant je obalit celý výpis do jednoho formuláře. Mnohem pohodlnější způsob nám však nabízí nový nástroj ve verzi 2.0: [api:Nette\\Application\\UI\\Multiplier].\n\nMultiplier umožňuje pohodlně definovat továrničku pro více komponent. Funguje na principu vnořených komponent - každá komponenta dědící od [api:Nette\\ComponentModel\\Container] může obsahovat další komponenty.\n\nViz kapitola o [komponentovém modelu| doc:components#toc-komponenty-do-hloubky] v dokumentaci či [přednáška od Honzy Tvrdíka| posobota-36-jan-tvrdik-komponenty]. .[tip]\n\nPodstatou Multiplieru je, že vystupuje v pozici rodiče, který si své potomky dokáže vytvářet dynamicky pomocí callbacku předaného v konstruktoru. Viz příklad:\n\n/--php\nprotected function createComponentShopForm()\n{\n	return new Multiplier(function () {\n		$form = new Nette\\Application\\UI\\Form;\n		$form->addText(\'count\', \'Počet zboží:\')\n			->addRule($form::FILLED)\n			->addRule($form::INTEGER);\n		$form->addSubmit(\'send\', \'Přidat do košíku\');\n		return $form;\n	});\n}\n\\--\n\nNyní můžeme v šabloně jednoduše u každého zboží nechat vykreslit formulář - a každý bude skutečně unikátní komponentou.\n\n/--html\n{foreach $items as $item}\n	<h2>{$item->title}</h2>\n	{$item->description}\n\n	{control shopForm-$item->id}\n{/foreach}\n\\--\n\nArgument předaný makru `{control}` je ve formátu, který říká:\n\n1. získej komponentu `shopForm`\n2. a z ní získej potomka `$item->id`\n\nPři prvním volání bodu **1.** `shopForm` ještě neexistuje, takže se zavolá jeho továrnička `createComponentShopForm`. Na získané komponentě (instanci Multiplieru) je pak zavolána továrnička konkrétního formuláře - což je anonymní funkce, kterou jsme Multiplieru v konstruktoru předali.\n\nV další iteraci foreache již metoda `createComponentShopForm` volána nebude (komponenta existuje), ale protože hledáme jejího jiného potomka (`$item->id` bude v každé iteraci jiné), znovu bude zavolána anonymní funkce a vrátí nám nový formulář.\n\nJediné, co zbývá, je zajistit, aby nám formulář do košíku přidal skutečně to zboží, které má - aktuálně je formulář u každého zboží úplně totožný. Pomůže nám vlastnost Multiplieru (a obecně každé továrničky na komponentu v Nette Frameworku), a to ta, že každá továrnička jako svůj první argument dostává název tvořené komponenty. V našem případě to bude `$item->id`, což je přesně ten údaj, který potřebujeme. Stačí tedy lehce upravit tvorbu formuláře:\n\n/--php\nprotected function createComponentShopForm()\n{\n	return new Multiplier(function ($itemId) {\n		$form = new Nette\\Application\\UI\\Form;\n		$form->addText(\'count\', \'Počet zboží:\')\n			->addRule($form::FILLED)\n			->addRule($form::INTEGER);\n		$form->addHidden(\'itemId\', $itemId);\n		$form->addSubmit(\'send\', \'Přidat do košíku\');\n		return $form;\n	});\n}\n\\--\n',	'cs',	0,	'public'),
  (67,	0,	'2015-04-24 19:39:16',	'2015-04-24 19:39:16',	3328,	'Připojení komponenty k rodiči',	'pripojeni-komponenty-k-rodici',	'Komponentou v terminologii Nette Frameworku je každá implementace [api:Nette\\ComponentModel\\IComponent]. O komponentách platí, že mohou mít rodiče. Ve skutečnosti tomu je tak, že ho bude mít každá (výjimku tvoří například [api:Nette\\Application\\UI\\Presenter], který stojí v roli nejvyššího rodiče, kořene komponentového stromu). Nás bude zajímat okamžik, kdy se komponenta ke svému rodiči připojuje.\n\nExistují 2 způsoby, jak se může komponenta ke svému rodiči připojit: konstruktor a metoda `addComponent()`.\n\nPřipojení přes konstruktor\n----------\n\n[Konstruktor třídy Nette\\ComponentModel\\Component| api:Nette\\ComponentModel\\Component::__construct()] rovnou poskytuje rozhraní pro nastavení rodiče. Prvním argumentem je instance rodiče, druhým je název komponenty. Jak vypadá využití tohoto rozhraní v praxi? Komponentu budeme typicky tvořit v továrničce:\n\n/--php\nprotected function createComponentFoobar($name)\n{\n	$foobar = new Foobar($this, $name);\n}\n\\--\n\nNaše komponenta `Foobar` (která samozřejmě dědí od `Component`) v továrničce přijímá za rodiče třídu, která ji tvoří. S takovýmto kódem se obvykle setkáváme v presenterech - a skutečně zcela logicky presenter je obvykle rodičem první generace našich komponent.\n\nPřipojení metodou `addComponent()`\n----------\n\nNette je však framework pro pohodlné a líné programátory, a tak nabízí užitečnou zkratku. Továrničky na komponenty (obecně všechny metody s prefixem `createComponent`) se volají v metodě [getComponent($name)|api:Nette\\ComponentModel\\Container::getComponent()] v případě, že požadovaná komponenta ještě nebyla vytvořena.\n\nPokud se podíváme do [útrob|api:source-ComponentModel\\Container.php::149] této metody, zjistíme, že instance vrácená z továrničky je ještě zkontrolována, zdali už má rodiče nastaveného. Pokud ne, je rodič (i jméno) nastaven druhou možnou cestou: manuálním přidáním potomka metodou [addComponent()|api:Nette\\ComponentModel\\Container::addComponent()] na rodiči. Díky ní můžeme továrničku zkrátit na nezbytné minimum, a starost o rodiče a jméno komponenty nechat frameworku.\n\n/--php\nprotected function createComponentFoobar()\n{\n	return new Foobar;\n}\n\\--\n\nTato skutečnost nám dovoluje i libovolně přepsat naší komponentě konstruktor. Ovšem vzhledem k tomu, že obvykle budeme dědit spíše od [api:Nette\\Application\\UI\\Control], je **do verze Nette 2.0.6** best-practice vždy volat `parent::__construct()`, ačkoliv spoleháme na 2. způsob nastavení rodiče. Od verze 2.0.7 to již potřeba není. .[note]\n\nJaké jsou rozdíly?\n----------\n\nSkoro by se chtělo říci, že 2. způsob by měl být díky své pohodlnosti jednoznačně upřednostněn. Věc se má však s komponentami krapet složitěji. Nesmíme totiž zapomenout na monitorování předků a s tím související metodu [attached()| api:Nette\\ComponentModel\\Component::attached()].\n\nTato `protected` metoda je volána v okamžiku připojení komponenty ke svému rodiči (tedy buď v konstruktoru nebo po vrácení nové komponenty z továrničky, jak jsme zmapovali ve 2. způsobu). A právě kvůli tomu je důležité, který ze způsobů připojení rodiče použijeme.\n\nJe třeba mít na paměti, že **před připojením k rodiči nemusí být komponenta v plně inicializovaném stavu** (nebude mít přístup k presenteru, který je ultimátním rodičem všech apod.).\n\nMůžeme si vzít za příklad formuláře. Obvykle používána implementace [api:Nette\\Application\\UI\\Form] si v metodě `attached()` nastavuje podle aktuálního presenteru atribut `action`. Pokud bychom tedy chtěli s touto vygenerovanou hodnotou dále pracovat v továrničce, musíme zajistit připojení formuláře k rodiči ještě předtím, tedy pomocí konstruktoru. V opačném případě nebude ještě hodnota `action` nastavena.',	'cs',	0,	'public'),
  (68,	0,	'2015-04-24 19:40:35',	'2015-04-24 19:40:35',	3328,	'Změna <title> při AJAXovém požadavku',	'zmena-title-pri-ajaxovem-pozadavku',	'\nPokud bychom chtěli při AJAXovém požadavku změnit titulek stránky (obsah značky `<title>` v hlavičce), máme na výběr dvě možnosti. Jednak můžeme využít javascriptové History API, konkrétně metodu `window.history.pushState()` (která nám umožňuje přepisovat historii prohlížení v browseru). Anebo se spokojíme s využitím snippetů.\n\nOd verze Nette 2.0 lze používat atributovou variantu makra `{snippet}`, čehož využijeme. A jak bude tedy AJAXová změna `<title>` pomocí snippetů vypadat v praxi?\n\n/--html\n<title n:snippet=\"title\">{#title|striptags|upper}Default Title{/#}</title>\n\\--\n\nInvalidace bude stejná jako u jakéhokoliv jiného snippetu:\n\n/--php\n$this->invalidateControl(\'title\');\n\\--\n\nV šabloně view pak můžeme pro ukázku implementovat dynamicky se měnící `<title>`:\n\n/--html\n<h1 n:block=\"title\">\n	{if $presenter->isAjax()}\n		Loaded With Ajax\n	{else}\n		No Ajax Heading\n	{/if}\n</h1>\n\\--\n\nUvedený kód počítá s přilinkovaným [obslužným skriptem pro AJAX | addons:cs/nette-ajax-js] z doplňků.\n',	'cs',	0,	'public'),
  (69,	0,	'2015-04-24 19:48:23',	'2015-04-24 19:48:23',	1639,	'Inject Autowire',	'inject-autowire',	'.[perex]\nPokud se budeme řídit pravidlem „>>Zapomeňte, že existuje nějaký `$this->context`,<<“ budeme si muset do presenterů předávat závislosti jiným způsobem.\n\nJednou z novinek v \"Nette 2.0.5\":http://forum.nette.org/en/1074-nette-framework-2-0-5-released je autowire pomocí *inject* metod v presenteru. Ve své podstatě se jedná o *setter injection* s jedním rozdílem oproti běžnému setteru -- bežný setter je možné volat opakovaně. Inject metody se naopak smí volat pouze jednou (v opačném případě by mohlo dojít k nečekanému chování) a metoda sama by v případě opakovaného volání **měla** vyhazovat výjimku.\n\n\nUkázka\n======\n\n/--php\nabstract class BasePresenter extends \\Nette\\Application\\UI\\Presenter\n{\n	/** @var Settings */\n	protected $settings;\n\n	/**\n	 * @param Settings\n	 */\n	public function injectSettings(Settings $settings)\n	{\n		if ($this->settings) {\n			throw new Nette\\InvalidStateException(\'Settings has already been set\');\n		}\n		$this->settings = $settings;\n	}\n\n	protected function beforeRender()\n	{\n		$this->template->appName = $this->settings->get(\'appName\');\n	}\n}\n\nclass ArticlesPresenter extends BasePresenter\n{\n	/** @var Articles */\n	protected $articles;\n\n	/**\n	 * @param Articles\n	 */\n	public function injectArticles(Articles $articles)\n	{\n		if ($this->articles) {\n			throw new Nette\\InvalidStateException(\'Articles has already been set\');\n		}\n		$this->articles = $articles;\n	}\n\n	public function renderDetail($id = 0)\n	{\n		// pochopitelně zde by nejprve měla být kontrola, zda vůbec článek existuje atd.\n		$this->template->article = $this->articles->find($id);\n	}\n}\n\\--\n\nNette nám **automaticky** do *Articles* presenteru předá námi očekávané služby, tj. službu, jež je typu `Articles` (skrze volání metody injectArticles) a službu typu `Settings` (již potřebuje BasePresenter).\n\n\nProblémy\n========\n\nAutowire je automatizace a žádná automatizace není zcela dokonalá. I autowiring pomocí *inject* metod má své mouchy.\n\nVíce instancí nebo implementací požadovaného typu\n-------------------------------------------------\n\nUvažujme, že máme takovouto *inject* metodu:\n\n/--php\npublic function injectFoo(IFoo $foo) { ... }\n\\--\n\nZároveň předpokládejme, že v [DI | doc:cs:dependency-injection] containeru máme více služeb implementujících námi žádané rozhraní `IFoo`. V tento moment nastává situace, kdy autowiring není technicky možný -- Nette není schopno rozpoznat, kterou z možných instancí požadujeme a vyhodí výjimku.\n\n.[tip]\nPodívejte se na potenciální budoucí řešení tohoto problému \"na fóru\":http://forum.nette.org/cs/11402-proof-of-concept-generics.\n\n\nParametry a továrničky\n----------------------\n\nSkrze *inject* metody lze předávat pouze služby (objekty). Nelze takto automaticky předávat továrničky, ani parametry.\n\n\nBudoucnost\n==========\n\nV aktuální vývojové verzi Nette (2.1-dev) jsou inject metody automaticky volány i na všech službách a továrničkách v *DI* containeru. Tuto funkcionalitu je možné u jednotlivých služeb nebo továrniček vypnout:\n\n/--neon\nservices:\n	foo:\n		class: Foo\n		inject: no # vypne volání inject\n\\--',	'cs',	0,	'public'),
  (70,	0,	'2015-04-24 19:48:16',	'2015-04-24 19:48:16',	1639,	'Stažení sandboxu přes Composer',	'stazeni-sandboxu-pres-composer',	'\n.[perex]\nJak stahovat Nette sandbox jednoduše pomocí Composeru?\n\nNejprve si nainstalujeme Composer podle [návodu | doc:cs:composer#instalace-do-operacniho-systemu]. A poté pomoci něj stáhneme sandbox do adresáře `myApp`:\n\n/--\ncomposer create-project nette/sandbox myApp 2.0.5\ncd myApp\n\\--\n\nPokud máte PHP 5.4 nebo vyšší, můžete rovnou spustit server příkazem:\n\n/--\nphp -S localhost:3000 -t www\n\\--\n\nA stránku `http://localhost:3000` otevřít v prohlížeči.\n\n\nSandbox pro vývojovou verzi Nette\n===========\n\nSandbox nainstalujeme stejným způsobem:\n\n/--\ncomposer create-project nette/sandbox myApp\ncd myApp\n\\--\n\nPokud máte PHP 5.4 nebo vyšší, můžete rovnou spustit server příkazem:\n\n/--\nphp -S localhost:3000 -t www\n\\--\n\nA stránku `http://localhost:3000` otevřít v prohlížeči.\n',	'cs',	0,	'public'),
  (71,	7,	'2015-04-24 19:50:05',	'2015-04-24 19:50:05',	1639,	'Vícenásobné použití samostatného formuláře',	'vicenasobne-pouziti-samostatneho-formulare',	'.[perex]\nMáte formulář v samostatné třídě? A chcete ho použít na více místech?\n\nTřída formuláře\n/--php\nclass LoginForm extends \\Nette\\Application\\UI\\Form\n{\n	/** @var \\Nette\\Security\\User */\n	private $user;\n\n	/**\n	 * @param \\Nette\\Security\\User\n	 */\n	public function __construct(\\Nette\\Security\\User $user)\n	{\n		parent::__construct();\n		$this->user = $user;\n\n		$this->addText(\'username\', \"Username\");\n		$this->addPassword(\'password\', \"Password\");\n\n		$this->addSubmit(\'sub\', \"Login\");\n\n		$this->onSuccess[] = callback($this, \'process\');\n	}\n\n	public function process()\n	{\n		$values = $this->getValues();\n\n		try {\n			$this->user->login($values->username, $values->password);\n		} catch (\\Nette\\Security\\AuthenticationException $e) {\n			$this->addError($e->getMessage());\n		}\n	}\n}\n\\--\n\nPři inicializaci zaregistrujeme callback, který nám zpracuje formulář.\n\nPoužití v presenteru:\n/--php\nclass LoginPresenter extends \\Nette\\Application\\UI\\Presenter\n{\n	/**\n	 * @return LoginForm\n	 */\n	protected function createComponentLoginForm()\n	{\n		$form = new LoginForm($this->getUser());\n\n		$presenter = $this;\n		$form->onSuccess[] = function($form) use($presenter) {\n			if ($form->valid) {\n				$presenter->restoreRequest($presenter->backlink);\n			}\n		}\n		return $form;\n	}\n}\n\\--\n\nV továrničce si zaregistrujeme druhý callback, který nám provede akci po úspěšném zpracování formuláře.\n',	'cs',	0,	'public'),
  (72,	7,	'2015-04-24 19:51:11',	'2015-04-24 19:51:11',	1639,	'Multiple use of single form',	'multiple-use-of-single-form',	'.[perex]\nDo you have form in separated class? Do you want to use it in several places?\n\n\nClass form\n---\n\n/--php\nclass LoginForm extends \\Nette\\Application\\UI\\Form\n{\n	/** @var \\Nette\\Security\\User */\n	private $user;\n\n	/**\n	 * @param \\Nette\\Security\\User\n	 */\n	public function __construct(\\Nette\\Security\\User $user)\n	{\n		parent::__construct();\n		$this->user = $user;\n\n		$this->addText(\'username\', \"Username\");\n		$this->addPassword(\'password\', \"Password\");\n\n		$this->addSubmit(\'sub\', \"Login\");\n\n		$this->onSuccess[] = callback($this, \'process\');\n	}\n\n	public function process()\n	{\n		$values = $this->getValues();\n\n		try {\n			$this->user->login($values->username, $values->password);\n		} catch (\\Nette\\Security\\AuthenticationException $e) {\n			$this->addError($e->getMessage());\n		}\n	}\n}\n\\--\n\nRegister callback processing the form during initialization.\n\nUse in presenter\n---\n/--php\nclass LoginPresenter extends \\Nette\\Application\\UI\\Presenter\n{\n	/**\n	 * @return LoginForm\n	 */\n	protected function createComponentLoginForm()\n	{\n		$form = new LoginForm($this->getUser());\n\n		$presenter = $this;\n		$form->onSuccess[] = function($form) use($presenter) {\n			if ($form->valid) {\n				$presenter->restoreRequest($presenter->backlink);\n			}\n		}\n		return $form;\n	}\n}\n\\--\n\nRegister second callback in factory, which will take action after valid processing of form.\n\n',	'en',	0,	'public'),
  (73,	0,	'2015-04-24 19:54:26',	'2015-04-24 19:54:26',	2027,	'Dynamický formulář jako modul (DRAFT)',	'dynamicky-formular-jako-modul-draft',	'.[perex]\nTento návod by měl posloužit všem, kteří s Nette frameworkem teprve začínají a potřebují detailnější návod krok za krokem. Dozvíte se zde, jak v [Nette framework|www:download] založit nový modul, který bude obsahovat formulář s dynamickým počtem prvků a závislými selecty.\n\nCo budeme potřebovat\n=====================\n- [Nette framework|www:download]\n- [Replikátor formulářových kontejnerů|addons:cs/form-container-replicator]\n- [Dynamicky závislý select|addons:cs/dependentselectbox]\n\nSlovníček pojmů\n===============\n**Dynamický formulář**:\n	- Struktura formuláře není definována přímo ve zdrojovém kódu, ale je nastavitelná například v databázi.\n**Dynamický počet prvků ve formuláři**:\n	- Počet prvků formuláře je ovlivnitelný z klientské strany. Například možnost přidat více než jeden telefon v kontaktním formuláři.\n**Závislé selectboxy**:\n	- Výběrem hodnoty z jednoho selectboxu se umožní vybrat hodnoty z jiného selectboxu, které přísluší k vybrané hodnotě. Například po výběru České Republiky v selectboxu \"Země\" se zpřístupní možnost výběru Českých měst v selectboxu \"Město\".\n\nZačínáme s Nette Frameworkem\n============================\nPro samotné rozchození [Nette Frameworku|www:download] existuje nejeden [detailní návod|doc:quickstart]. Bude tedy následovat jen zjednodušený postup.\n\nStažení a rozbalení frameworku\n------------------------------\nZe stránek [Nette Framework download|www:download] stáhneme nejnovější zip archiv zvýrazněný v samotném záhlaví stránky. V době psaní tohoto návodu se jedná o \"Nette Framework 2.0.3 pro PHP 5.3 nebo 5.4 .(Vyžaduje PHP ve verzi 5.3.0 nebo vyšší)\":http://files.nette.org/releases/2.0/NetteFramework-2.0.3-PHP5.3.zip .[downloadMain]\n\nPo rozbalení tohoto archivu nalezneme složku nazvanou \"sandbox\", která obsahuje základní a doporučenou adresářovou strukturu aplikace. Obsah složky sandbox zkopírujeme do složky projektu. Význam a obsah jednotlivých složek je popsán ve výborném návodu nazvaném [začínáme|doc:quickstart/getting-started].\nPokud jsme udělali všechno správně, měla by nás po zadání webové adresy projektu do prohlížeče přivítat následující stránka.\n\n[* nette-framework-quickstart.png *] .<>\n\nVytvoření modulu\n----------------\nKdyž bychom chtěli mít na jedné webové adrese více než jednu aplikaci (například webovou prezentaci, eshop, redakční systém a třeba nástroj na faktury), je technologie modulů to co nám umožní zachovat i v tak rozsáhlém kódu pořádek. Umožňuje oddělit jednotlivé \"aplikace\" do samostatných složek a přesto zachovat doporučenou strukturu pro oddělení Modelů, Presenterů a Tempalte.\n\nOsobně preferuji vždy ukládat kód do modulů, jelikož nikdy nevím, kdy se bude muset přidat další technologie, která se stávajícím projektem nemá nic společného, nebo kdy se rozhodnu jednotlivou část umístit na vlastní server například z důvodu bezpečnosti nebo výkonu. .[tip]\n\nNejprve upravíme výchozí routu v souboru //bootstrap.php// aby směřovala na nově vznikající modul. Detailní rozbor jak vytvářet routy nalezneme v manuálu [Routování URL|doc:routing]. Pro účel tohoto návodu postačí, když nahradíme výchozí routy za následující kód:\n/--php\n// Setup router\n//$container->router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\n//$container->router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n$container->router[] = new Route(\'index.php\', \'DynamicForm:DynamicForm:default\', Route::ONE_WAY);\n$container->router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n	\'module\' => \'DynamicForm\',\n	\'presenter\' => \'DynamicForm\',\n	\'action\' => \'default\'\n));\n\\--\nTím jsme řekli [Nette Frameworku|www:], že když někdo zadá do prohlížeče adresu našeho projektu, první co uvidí bude akce //default// umístěná v presenteru //DynamicForm// který bude umístěn v modulu //DynamicForm//. Jelikož modul ani jeho presenter ještě neexistuje, přivítá nás následující stránka, která nám pomůže vytvořit vše potřebné.\n\n[* cannot-load-presenter.png *] .<>\n\nJak je z chybové zprávy patrnné, budeme potřebovat založit složku modulu. Bude vhodné rovnou založit i základní strukturu podsložek (models, presenters a templates) to vše ve složce //app// umístěné v kořenovém adresáři projektu. Měli bychom dodržet jmennou konvenci a v názvu uvést, že se jedná o modul uvedením koncovky \"Module\". Výsledek by tedy měl vypadat následovně:\n/--\napp/\n+-- config/\n+-- DynamicFormModule\n	+-- models\n	+-- presenters\n	+-- temlates\n+-- models/\n+-- presenters/\n+-- templates/\n+-- bootstrap.php\n\\--\n\nDo složky //presenters// v adresáři modulu vytvoříme soubor //BasePresenter.php// který bude obsahovat základní presenter našeho modulu. Tento presenter nám poslouží vždy, když budeme potřebovat nastavit něco společného pro všechny presentery v tomto modulu, ale nebudeme tím chtít ovlivnit jiné moduly. A to se může stát dříve či později, tak se na to připravíme a vytvoříme si základní presenter. //Však nám ruce neupadnou. ;)// Soubor //BasePresenter.php// bude obsahovat následující kód:\n/--php\n<?php\n\nnamespace DynamicFormModule;\n\n/**\n * BasePresenter\n * @author Pavel Železný <info@pavelzelezny.cz>\n */\nclass BasePresenter extends \\BasePresenter\n{\n\n}\n\\--\nJak můžeme vidět, aby se nepletl BasePresenter modulu od BasePresenteru celé aplikace, využívá se technologie [jmenných prostorů|http://www.php.net/manual/en/language.namespaces.rationale.php], která přichází až s PHP 5.3.\n\nDále vytvoříme soubor //DynamicFormPresenter.php// který bude obsluhovat vykreslovaní našeho formuláře a který umístíme do složky //presenters// v adresáři našeho modulu. Obsah tohoto souboru bude následnovný:\n/--php\n<?php\n\nnamespace DynamicFormModule;\n\n/**\n * DynamicFormPresenter\n * @author Pavel Železný <info@pavelzelezny.cz>\n */\nclass DynamicFormPresenter extends \\DynamicFormModule\\BasePresenter\n{\n\n	/**\n	 * Render default action\n	 * @author Pavel Železný <info@pavelzelezny.cz>\n	 * @return void\n	 */\n	public function renderDefault()\n	{\n\n	}\n\n}\n\\--\n.[tip]\nDoporučení Davida Grudla zde na fóru ([Nápověda k editaci stránek|napoveda-k-editaci-stranek]) je neuvádět zbytečně jmenné prostory při volání tříd, ale posuďte sami, jak snadno se jeden zplete, když se základní presenter aplikace a modulu jemnují stejně a rozdíl by zde byl pouze v uvední zpětného lomíka před názvem //\\BasePresenter//.\n\nOd tohoto momentu máme připravený základ modulu. Nyní nás po zadání webové adresy projektu do prohlížeče přivítá následující stránka:\n\n[* page-not-found.png *] .<>\n\nZde nás [Nette Framework|www:] informoval, že mu ještě schází výchozí latte šablona pro náši akci. Vytvoříme tedy soubor //default.latte// umístěný v příslušném adresáři (///app/DynamicFormModule/templates/DynamicForm/default.latte//), jak nám radí chybová zpráva. Obsah souboru bude následovný:\n/--\n{**\n  * Template for default action of DynamicFormPresenter\n  * @author Pavel Železný <info@pavelzelezny.cz>\n  *}\n\n{block content}\n<div id=\"banner\">\n	<h1>Dynamic Form</h1>\n</div>\n<div id=\"content\">\n	<h2>You have successfully created your Nette Framework module.</h2>\n</div>\n{/block}\n\\--\n\nJakmile teď vstoupíme na adresu našeho projektu, uvítá nás následující stránka:\n\n[* dynamic-form-module-start.png *] .<>\n\nTímto máme připravený píseček v podobě nového modulu, do kterého budeme následovně vykreslovat dynamický formulář s dynamickým počtem prvků a závislými selectboxy.\n',	'cs',	0,	'public'),
  (74,	8,	'2015-04-24 20:46:32',	'2015-04-24 20:46:32',	3705,	'Nette a Grunt',	'nette-a-grunt',	'Jak snadno minifikovat js a css soubory pomoci Gruntu v Nette projektu\n\n\nProč toto spojeni?\n--------------------\n\nProtoze každý chce mít jen jeden javascript soubor a jeden css soubor. V době mobilniho internetu, kde se každý request počítá nechceme hlavičky nasich stranek co vypadaji nejak takhle (v lepsim pripade)\n\n[* grunt-drupal.png *]\n\nChceme jen jeden minifikovany soubor pro javascript a jeden minifikovany soubor pro css. A jelikoz na tyto ukoly se mi velmi dobre osvedcil Grunt a jeho kanonada pluginu, predstavim vam jednoduche reseni jak si tento proces automatizovat.\n\n\nCo budem potřebovat.\n-------------\n\nČistou “instalaci” Nette sandboxu https://github.com/nette/sandbox a fungujici Grunt http://gruntjs.com.\n\n.[tip]\nGrunt je JavaScript task runner, defakto něco jako Make ci Ant ale napsane v JavaScriptu. Existuje pro nej spousta zajimavych pluginu/tasku ktere jsou uzitecne ve frontendovem vyvoji (ale nejen i v nem) viz gruntjs.com/plugins.\n\nJak zprovoznit grunt-cli:\n\nGrunt pohani node.js tudiz je treba mit nainstalovan node.js s package managerem npm (nodejs.org)\n\nnasledne do globalniho prostoru nainstalujeme grunt-cli\n`npm install -g grunt-cli`\n\npokud vse dobre dopadlo melo by se po zadani grunt --version objevit neco podobneho\n\n\n[* grunt-version.png *]\n\n\nV adresari ProjectGrunt si zprovoznime fungujici Nette Sandbox. Idealne pomoci composer prikazu\n\n`composer create-project nette/sandbox ProjectGrunt`\n\n[* grunt-nette-sandbox-composer.png *]\n\n\nnasledne si zkontrolujeme obsah slozky\n\n\n[* grunt-folder.png *]\n\na po nastaveni webserveru a nastaveni log a temp (`chmod -R a+rw temp log`) bychom meli videt funguji stranku. ( nefunguje? Postupujte podle [Quick startu | http://doc.nette.org/en/2.1/quickstart/getting-started])\n\n\n\nJdeme na to\n-------------\n\ndo hlavniho adresare pridame soubor *package.json* ve kterem specifikujeme npm zavislosti pro nas grunt skript\n\n/--\n{\n  \"name\": \"ProjectGrunt\",\n  \"version\": \"1.0.0\",\n  \"devDependencies\": {\n    \"grunt\": \"~0.4.4\",\n    \"grunt-usemin\": \"~2.1.0\",\n    \"grunt-contrib-concat\": \"~0.3.0\",\n    \"grunt-contrib-uglify\": \"~0.4.0\",\n    \"grunt-contrib-cssmin\": \"~0.9.0\",\n    \"grunt-nette-basepath\": \"~0.2.0\"\n  }\n}\n\\--\n\n**grunt** - rikame ze chceme pouzivat Grunt ve verzi 0.4.4\n\n\n**grunt-usemin** - plugin pro prochazeni html souboru a dohledavani js a css souboru k dalsimu zpracovani\n\n**grunt-contrib-concat** - plugin pro spojovani vice souboru do jednoho\n\n**grunt-contrib-uglify** - plugin pro minifikaci javascript souboru\n\n**grunt-contrib-cssmin** - plugin pro minifikaci css souboru\n\n**grunt-nette-basepath** - plugin pro odstraneni latte promene {$basePath}\n\n\nInstalaci provedeme prikazem `npm install`\n\n[* grunt-npm-install.png *]\n\nA nasledne do hlavniho adresare pridame jeste *Gruntfile.coffee* (muzete pouzit i Gruntfile.js ale z vlastni zkusenosti doporucuji Coffee, prece jen je tam o poznani mene zavorek, stredniku a vseho mozneho :-) )\n\n/--\nmodule.exports = (grunt) ->\n  grunt.initConfig\n    useminPrepare:\n      html: [\'app/templates/@layout.latte\']\n      options:\n        dest: \'.\'\n\n    netteBasePath:\n      basePath: \'www\'\n      options:\n        removeFromPath: [\'app/templates/\']\n\n  # These plugins provide necessary tasks.\n  grunt.loadNpmTasks \'grunt-contrib-concat\'\n  grunt.loadNpmTasks \'grunt-contrib-uglify\'\n  grunt.loadNpmTasks \'grunt-contrib-cssmin\'\n  grunt.loadNpmTasks \'grunt-usemin\'\n  grunt.loadNpmTasks \'grunt-nette-basepath\'\n\n  # Default task.\n  grunt.registerTask \'default\', [\n    \'useminPrepare\'\n    \'netteBasePath\'\n    \'concat\'\n    \'uglify\'\n    \'cssmin\'\n  ]\n\\--\n\nZde je definicie jake tasky se maji nacist. Jak se chova hlavni task (to je ten co se spusti prikazem grunt) a konfigurace pro task useminPrepare a netteBasePath. Vice informaci jak funguje usemin plugin najdete na https://github.com/yeoman/grunt-usemin\n\nV nasem pripade si jeste overime konfiguraci pro netteBasePath kde rikame ze basePath se nachazi v adresari www a z duvodu jak funguje useminPrepare potrebujeme odsranit jeste zanoreni *app/templates* ktere k souborum plugin pridava.\n\n.[error]\npro platformu windows je mozne ze bude nutna drobna uprava konfigurace na\n/--\nremoveFromPath: [\'app\\\\templates\\\\\']\n\\--\n(o problemu vim a casem ho snad vyresim)\n\n\nSpustime minifikaci\n-----------------\n\nTed kdyz mame vse tak uz by nam melo jit spustit  `grunt` , ale v tuto chvili skoncime s chybou jelikoz usemin plugin nenasel zadne bloky k minifikaci.\n\n[* grunt-usemin-error.png *]\n\nTak si tam ty bloky pridame :) V souboru *@layout.latte* najdeme a obalime klasicke nacitani css a js\n\n\n/--html\n<!-- build:css {$basePath}/css/screen.min.css -->\n<link rel=\"stylesheet\" media=\"screen,projection,tv\" href=\"{$basePath}/css/screen.css\">\n<!-- endbuild -->\n<!-- build:css {$basePath}/css/print.min.css -->\n<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.css\">\n<!-- endbuild -->\n\\--\n\na\n\n/--html\n<!-- build:js {$basePath}/js/app.min.js -->\n<script src=\"{$basePath}/js/jquery.js\"></script>\n<script src=\"{$basePath}/js/netteForms.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n<!-- endbuild -->\n\\--\n\na ted by spustenim `grunt` mel najit nase definovane soubory v blocich a postarat se o ne.\n\n[* grunt-success.png *]\n\nSuper, v adresari se nam objevil minifikovane verze, co ted s nima?\n\n\nPrepinani verzi v latte\n--------------------------\n\nPro vyvoj budeme chtit neminifikovane vicesouborove reseni a pro nasazeni na produkci budeme chtit zobrazovat minifikovanou verzi.\n\n\nJak toho docilit. Ja si definoval v neon.configu promenou ktera mi rika jakou verzi chci pouzit pripadne mam i jeji verzove pojmenovani (kvuli cache)\n\n*config.neon*\n\n/--neon\n#\n# SECURITY WARNING: it is CRITICAL that this file & directory are NOT accessible directly via a web browser!\n#\n# If you don\'t protect this directory from direct web access, anybody will be able to see your passwords.\n# http://nette.org/security-warning\n#\nparameters:\n	site: # <---\n		develMode: false # <---\n		version: blackhawk # <---\n\nphp:\n	date.timezone: Europe/Prague\n	# zlib.output_compression: yes\n\n\nnette:\n	application:\n		errorPresenter: Error\n		mapping:\n			*: App\\*Module\\Presenters\\*Presenter\n\n	session:\n		expiration: 14 days\n\n\nservices:\n	- App\\Model\\UserManager\n	- App\\RouterFactory\n	router: @App\\RouterFactory::createRouter\n\\--\n\nDrobna uprava v basepresenteru aby se o techto parametrech dozvedela sablona, asi to neni nejcistsi reseni ale pro tento priklad nam to staci a nebudeme si to komplikovat.\n\n*BasePresenter.php*\n\n/--php\n/**\n * Base presenter for all application presenters.\n */\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter\n{\n	public function beforeRender()\n	{\n		parent::beforeRender();\n\n		$this->template->production = !$this->context->parameters[\'site\'][\'develMode\'];\n		$this->template->version = $this->context->parameters[\'site\'][\'version\'];\n	}\n}\n\\--\n\na nasledna uprava v sablone *@layout.latte*\n\n/--html\n{if $production}\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/screen.min.css?{$version}\">\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.min.css?{$version}\">\n{else}\n	<!-- build:css {$basePath}/css/screen.min.css -->\n	<link rel=\"stylesheet\" media=\"screen,projection,tv\" href=\"{$basePath}/css/screen.css\">\n	<!-- endbuild -->\n	<!-- build:css {$basePath}/css/print.min.css -->\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.css\">\n	<!-- endbuild -->\n{/if}\n\\--\n\na\n\n/--html\n{if $production}\n	<script src=\"{$basePath}/js/app.min.js?{$version}\"></script>\n{else}\n	<!-- build:js {$basePath}/js/app.min.js -->\n	<script src=\"{$basePath}/js/jquery.js\"></script>\n	<script src=\"{$basePath}/js/netteForms.js\"></script>\n	<script src=\"{$basePath}/js/main.js\"></script>\n	<!-- endbuild -->\n{/if}\n\\--\n\na ted uz by nase aplikace mela pouzivat minifikovane verze.\n\n[* grunt-final-sourcecode.png *]\n\nCely projekt najdete na https://github.com/chemix/Nette-Grunt\n',	'cs',	0,	'public'),
  (75,	8,	'2015-04-24 19:57:14',	'2015-04-24 19:57:14',	3705,	'Nette with Grunt',	'nette-with-grunt',	'Why this friendship?\n--------------------\n\nBecause everyone can have only **one javascript** and **one stylesheet** file. In era of mobile internet, when every request is expensive, we don\'t want header like this (in better example)\n\n[* grunt-drupal.png *]\n\nWhat we want is that one minified javascript file and one minified file with stylesheets. I have got the best experience with Grunt and his great garden of plugins. I will show you simple example how to automate this task.\n\n\nWhat we need.\n-------------\n\nClean installation of Nette sandbox https://github.com/nette/sandbox and working Grunt http://gruntjs.com.\n\n\n.[tip]\nGrunt is JavaScript task runner. It’s similar to Make or Ant but written in JavaScript. Grunt has a lot of interesting plugins for better fronted development, but not only for frontend. Look at gruntjs.com/plugins.\n\nHow to install grunt-cli:\n\nGrunt requires node.js in the latest version and a package manager npm http://nodejs.org.\n\nWhen we already have npm with node.js installed, we can install grunt-cli to global space.\n`npm install -g grunt-cli`\n\nIf everything works, after you run command `grunt --version` you should see something like this.\n\n[* grunt-version.png *]\n\n\nLet\'s prepare working version of Nette Sandbox in ProjectGrunt folder. The best way how to do this, is by using composer.\n\n`composer create-project nette/sandbox ProjectGrunt`\n\n[* grunt-nette-sandbox-composer.png *]\n\n\nCheck folder content.\n\n[* grunt-folder.png *]\n\n\n\nAfter you configured web server and adjusted permission for log and temp folders (`chmod -R a+rw temp log`)  sandbox clone should work. If it doesn\'t work, you should follow [Quick start |  http://doc.nette.org/en/2.1/quickstart/getting-started] guide.\n\n\n\nConfiguration\n-------------\n\nCreate file *package.json* in root folder. It contains list of node.js modules what we need to install (using npm).\n\n/--\n{\n  \"name\": \"ProjectGrunt\",\n  \"version\": \"1.0.0\",\n  \"devDependencies\": {\n    \"grunt\": \"~0.4.4\",\n    \"grunt-usemin\": \"~2.1.0\",\n    \"grunt-contrib-concat\": \"~0.3.0\",\n    \"grunt-contrib-uglify\": \"~0.4.0\",\n    \"grunt-contrib-cssmin\": \"~0.9.0\",\n    \"grunt-nette-basepath\": \"~0.2.0\"\n  }\n}\n\\--\n\n**grunt** - use latest version of Grunt\n\n**grunt-usemin** - plugin for analysing our templates and prepare blocks with files for the next processes\n\n**grunt-contrib-concat** - plugin for concatenation files\n\n**grunt-contrib-uglify** - plugin for javascript minification\n\n**grunt-contrib-cssmin** - plugin for css minification\n\n**grunt-nette-basepath** - plugin for removing latte variable {$basePath} from file paths\n\n\nInstall these dependencies `npm install`\n\n[* grunt-npm-install.png *]\n\nCreate file *Gruntfile.coffee* in project root. You can use Gruntfile.js but I prefer Coffee for its expressiveness.\n\n/--\nmodule.exports = (grunt) ->\n  grunt.initConfig\n    useminPrepare:\n      html: [\'app/templates/@layout.latte\']\n      options:\n        dest: \'.\'\n\n    netteBasePath:\n      basePath: \'www\'\n      options:\n        removeFromPath: [\'app/templates/\']\n\n  # These plugins provide necessary tasks.\n  grunt.loadNpmTasks \'grunt-contrib-concat\'\n  grunt.loadNpmTasks \'grunt-contrib-uglify\'\n  grunt.loadNpmTasks \'grunt-contrib-cssmin\'\n  grunt.loadNpmTasks \'grunt-usemin\'\n  grunt.loadNpmTasks \'grunt-nette-basepath\'\n\n  # Default task.\n  grunt.registerTask \'default\', [\n    \'useminPrepare\'\n    \'netteBasePath\'\n    \'concat\'\n    \'uglify\'\n    \'cssmin\'\n  ]\n\\--\n\nThis includes definition of all tasks that will be loaded. And then it will be specified defaul main task which is run after command `grunt` and configuration for tasks useminPrepare and netteBasePath. For more information how plugin Usemin works visit https://github.com/yeoman/grunt-usemin.\n\nIn our case, we check config of netteBasePath task, where we said that basePath folder is in folder www, because Usemin plugin add to path folder, where file is located. We need to remove this path app/templates.\n\n.[error]\nif you are running grunt under windows, this setting must be in windows style\n/--\nremoveFromPath: [\'app\\\\templates\\\\\']\n\\--\n(I know this bug, and I will fix it later)\n\n\nRun minification\n-----------------\n\nNow we can run  `grunt` , but we got this error, because we don’t have blocks for usemin task in our template\n\n[* grunt-usemin-error.png *]\n\nSo we add these block to our template. In @layout.latte file we find classic javascript and css including and wrap it to build blocks.\n\n/--html\n<!-- build:css {$basePath}/css/screen.min.css -->\n<link rel=\"stylesheet\" media=\"screen,projection,tv\" href=\"{$basePath}/css/screen.css\">\n<!-- endbuild -->\n<!-- build:css {$basePath}/css/print.min.css -->\n<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.css\">\n<!-- endbuild -->\n\\--\n\nand\n\n/--html\n<!-- build:js {$basePath}/js/app.min.js -->\n<script src=\"{$basePath}/js/jquery.js\"></script>\n<script src=\"{$basePath}/js/netteForms.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n<!-- endbuild -->\n\\--\n\nand now  `grunt`  looks for block definitions and prepares files for next tasks.\n\n[* grunt-success.png *]\n\nGreat! Now we have minified files in folders, what is next?\n\n\nVersion switching in Latte\n--------------------------\n\nFor devel version we want uncompressed files, but for production we want use minified version.\n\nHow can we do this? I use configuration in neon.config where I define what version want to use and second config for version name to solve cache problems\n\n*config.neon*\n\n/--neon\n#\n# SECURITY WARNING: it is CRITICAL that this file & directory are NOT accessible directly via a web browser!\n#\n# If you don\'t protect this directory from direct web access, anybody will be able to see your passwords.\n# http://nette.org/security-warning\n#\nparameters:\n	site: # <---\n		develMode: false # <---\n		version: blackhawk # <---\n\nphp:\n	date.timezone: Europe/Prague\n	# zlib.output_compression: yes\n\n\nnette:\n	application:\n		errorPresenter: Error\n		mapping:\n			*: App\\*Module\\Presenters\\*Presenter\n\n	session:\n		expiration: 14 days\n\n\nservices:\n	- App\\Model\\UserManager\n	- App\\RouterFactory\n	router: @App\\RouterFactory::createRouter\n\\--\n\nUpdate in BasePresenter so that templates know about these variables. Maybe it’s not the best solution, but good enough for this example.\n\n*BasePresenter.php*\n\n/--php\n/**\n * Base presenter for all application presenters.\n */\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter\n{\n	public function beforeRender()\n	{\n		parent::beforeRender();\n\n		$this->template->production = !$this->context->parameters[\'site\'][\'develMode\'];\n		$this->template->version = $this->context->parameters[\'site\'][\'version\'];\n	}\n}\n\\--\n\nand update *@layout.latte*\n\n/--html\n{if $production}\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/screen.min.css?{$version}\">\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.min.css?{$version}\">\n{else}\n	<!-- build:css {$basePath}/css/screen.min.css -->\n	<link rel=\"stylesheet\" media=\"screen,projection,tv\" href=\"{$basePath}/css/screen.css\">\n	<!-- endbuild -->\n	<!-- build:css {$basePath}/css/print.min.css -->\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.css\">\n	<!-- endbuild -->\n{/if}\n\\--\n\nand\n\n/--html\n{if $production}\n	<script src=\"{$basePath}/js/app.min.js?{$version}\"></script>\n{else}\n	<!-- build:js {$basePath}/js/app.min.js -->\n	<script src=\"{$basePath}/js/jquery.js\"></script>\n	<script src=\"{$basePath}/js/netteForms.js\"></script>\n	<script src=\"{$basePath}/js/main.js\"></script>\n	<!-- endbuild -->\n{/if}\n\\--\n\nand now our application uses minified version\n\n[* grunt-final-sourcecode.png *]\n\nYou can find whole example on github https://github.com/chemix/Nette-Grunt\n\n\n',	'en',	0,	'public'),
  (76,	9,	'2015-04-24 19:58:40',	'2015-04-24 19:58:40',	1928,	'Jak otevřít soubor v editoru z Tracy?',	'jak-otevrit-soubor-v-editoru-z-tracy',	'\nPři zobrazení chybové stránky lze kliknout na jména souborů a ty se otevřou ve vašem editoru s kurzorem na příslušné řádce. Aby se tak stalo, je potřeba prohlížeč a systém nakonfigurovat. .[perex]\n\nPokud proměnnou **`Tracy\\Debugger::$editor`** nenastavíte, bude [Laděnka | doc:cs/debugging] standardně otevírat soubory přes URL `editor://open/?file=%file&line=%line`, tj. s protokolem **\"editor://\"**.\n\nPro ten si zaregistrujeme vlastní obsluhu. Tou může být libovolný spustitelný soubor, který \"přežvýká\" parametry a spustí náš oblíbený editor.\n\nWindows\n========\n\n**1. Vytvořte handler protokolu \"editor://\" ve formě dávkového souboru `run-editor.js`**\n\n/---code js\n// NetBeans\nvar editor = \'\"C:\\\\Program Files\\\\NetBeans 7.0\\\\bin\\\\netbeans.exe\" \"%file%:%line%\" --console  suppress --nosplash\';\n\n// PhpStorm\n//~ var editor = \'\"C:\\\\Program Files\\\\PhpStorm\\\\PhpStorm.exe\" --line %line% \"%file%\"\';\n\n// jEdit\n//~ var editor = \'\"C:\\\\Program Files (x86)\\\\jEdit\\\\jedit.exe\" \"%file%\" +line:%line% -reuseview\';\n\n// PHPEd\n//~ var editor = \'\"C:\\\\Program Files\\\\NuSphere\\\\PhpED\\\\phped.exe\" \"%file%\" --line=%line%\';\n\n// SciTE\n//~ var editor = \'\"C:\\\\Program Files\\\\SciTE\\\\scite.exe\" \"-open:%file%\" -goto:%line%\';\n\n// EmEditor\n//~ var editor = \'\"C:\\\\Program Files\\\\EmEditor\\\\EmEditor.exe\" \"%file%\" /l %line%\';\n\n// PSPad Editor\n//~ var editor = \'\"C:\\\\Program Files\\\\PSPad editor\\\\PSPad.exe\" -%line% \"%file%\"\';\n\n// gVim\n//~ var editor = \'\"C:\\\\Program Files\\\\Vim\\\\vim73\\\\gvim.exe\" \"%file%\" +%line%\';\n\n// Sublime Text 2\n//~ var editor = \'C:\\\\Progra~1\\\\Sublim~1\\\\sublime_text.exe \"%file%\":%line%\';\n\nvar url = WScript.Arguments(0);\nvar match = /^editor:\\/\\/open\\/\\?file=(.+)&line=(\\d+)$/.exec(url);\nif (match) {\n	var file = decodeURIComponent(match[1]).replace(/\\+/g, \' \');\n	var command = editor.replace(/%line%/g, match[2]).replace(/%file%/g, file);\n	var shell = new ActiveXObject(\"WScript.Shell\");\n	shell.Exec(command.replace(/\\\\/g, \'\\\\\\\\\'));\n}\n\\---\n\n**2. Zaregistrujte handler protokolu \"editor://\" v systému**\n\nVytvořte si a spusťte soubor **`editor.reg`**:\n\nPozor na dvojitá lomítka a úplnou cestu k souboru **`run-editor.js`** .[note]\n\n/---\nREGEDIT4\n\n[HKEY_CLASSES_ROOT\\editor]\n@=\"URL:editor Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\editor\\shell\\open\\command]\n@=\"wscript \\\"C:\\\\path\\\\to\\\\run-editor.js\\\" \\\"%1\\\"\"\n\\---\n\n\nLinux\n======\n\n1. **Vytvořte handler protokolu \"editor://\" ve formě BASH skriptu `run-editor.sh`**.\n\nV adresáři **`~/bin`** si vytvořte soubor **`~/bin/run-editor.sh`**,\n\n/---\ntouch ~/bin/run-editor.sh\n\\---\n\nučiňte jej spustitelným,\n\n/---\nchmod +x ~/bin/run-editor.sh\n\\---\n\na vložte do něj:\n\n/---\n#!/bin/bash\n\nurl=\"$1\"\nREWRITE=( $(FIS=\" \" echo \"$(echo $url | sed -s \'s/%2F/\\//g\' | sed -s \'s/.*file=\\(\\/.*\\)\\&line=\\(.*\\)/\\1\\ \\2/\')\") );\n\nline=${REWRITE[1]}\nfile=${REWRITE[0]}\n\n# Netbeans\nnetbeans \"$file:$line\"\n# Kate\n#kate --line $line \"$file\"\n# Vim\n#vim \"$file\" +$line\n# Gedit\n#gedit +$line \"$file\"\n# Komodo\n#komodo \"$file#$line\"\n# PhpStorm\n#/usr/local/bin/pstorm --line $line \"$file\"\n# Sublime Text 2\n#subl \"$file:$line\"\n\\---\n\nPokud používáte Netbeans (nebo jiné IDE) a nemáte jej nainstalované z balíku, pravděpodobně nebude Netbeans binárka v $PATH. To lze jednoduše napravit. V adresáři **`~/bin`** si vytvořte symlink na binárku Netbeans. .[note]\n\n2. **Zaregistrujte handler protokolu \"editor://\" v systému**\n\nKDE 4\n--------\n\nV KDE 4 tak učiňte editací konfiguračního souboru.\n Do souboru **`/usr/share/kde4/services/editor.protocol`** vložte\n\n/---\n[Protocol]\nexec=/home/<username>/bin/run-editor.sh \"%u\"\nprotocol=editor\ninput=none\noutput=none\nhelper=true\nlisting=\nreading=false\nwriting=false\nmakedir=false\ndeleting=false\n\\---\n\nGnome\n--------\n\nV Gnome zaregistrujeme handler protokolu \"editor://\" pomocí volání konfigurační utility\n\n/---\ngconftool-2 -s /desktop/gnome/url-handlers/editor/command --type String \'/home/<username>/bin/run-editor.sh %s\'\ngconftool-2 -s /desktop/gnome/url-handlers/editor/enabled --type Boolean true\n\\---\n\npro Vim či jiný konzolový editor přidejte:\n\n/---\ngconftool-2 -s /desktop/gnome/url-handlers/editor/needs_terminal --type Boolean true\n\\---\n\nPozor na kompletní cestu. Zkratka pomocí ~/ nefunguje protože se jedná o globální konfigurák. .[note]\n\nXfce\n-------\n\nV Xfce lze pro registraci protokolu využít balíček xdg-utils.\n\nVytvořte nový soubor `/usr/share/applications/editor-uri.desktop` a do něj vložte následující kód:\n\n/---\n[Desktop Entry]\nEncoding=UTF-8\nName=Editor Url\nType=Application\nExec=/home/<username>/bin/run-editor.sh %u\nTerminal=false\nCategories=Application;\nMimeType=x-scheme-handler/editor\nNoDisplay=true\n\\---\n\nNásledně editujte soubor `/usr/share/applications/defaults.list` a přidejte do něj následující řádek:\n\n/---\nx-scheme-handler/editor=editor-uri.desktop\n\\---\n\n\nMac OS X\n========\n\nPokud používáte editor **TextMate** nebo jiný, který umožňuje otevírat soubory přes speciální URL, bude vám stačit toto URL nastavit. Jako proměnné se tu používá %file a %line:\n\n/---code php\n// TextMate\nDebugger::$editor = \'txmt://open/?url=file://%file&line=%line\';\n// MacVim\nDebugger::$editor = \'mvim://open?url=file:///%file&line=%line\';\n\\---\n\nTroubleshooting:\n===========\n\n- ve Firefoxu může být potřeba protokol povolit pomocí network.protocol-handler.expose.editor nebo network.protocol-handler.expose-all v about:config. Ve výchozím nastavení je to ovšem povoleno :)\n- Pokud vám to hned nepůjde nepanikařte. A zkuste párkrát refreshnout stránku před klikem na onen odkaz. Rozjede se to!\n\nS případnými dotazy nebo připomínkami se prosím obraťte na [fórum | http://forum.nette.org/cs/5464-jak-nastavit-nette-debug-aby-oteviral-soubory-ve-vasem-editoru].\n',	'cs',	0,	'public'),
  (77,	9,	'2015-04-24 19:59:08',	'2015-04-24 19:59:08',	1928,	'Opening files in IDE by one click from Tracy\'s page',	'opening-files-in-ide-by-one-click-from-tracy-s-page',	'When error page is displayed, you can click on a file name to open relevant file in your editor, of course having having cursor in appropriate line of code. To make all this work, you need to configure your system little bit. .[perex]\n\nIf not configured otherwise by re-setting variable **`Tracy\\Debugger::$editor`**, [Debugger | doc:en/debugging] will open files using URL having this format: `editor://open/?file=%file&line=%line`, i.e. using **\"editor://\"** protocol. You need to register a handler in your system, which can be any executable file able to process passed URL.\n\nWindows\n========\n\n**1. Create **\"editor://\"** protocol handler in form of a batch file `run-editor.js`**\n\n/---code js\n// NetBeans\nvar editor = \'\"C:\\\\Program Files\\\\NetBeans 6.9.1\\\\bin\\\\netbeans.exe\" \"%file%:%line%\" --console suppress\';\n\n// PHPEd\n//~ var editor = \'\"C:\\\\Program Files\\\\NuSphere\\\\PhpED\\\\phped.exe\" \"%file%\" --line=%line%\';\n\n// PhpStorm\n//~ var editor = \'\"C:\\\\Program Files\\\\PhpStorm\\\\PhpStorm.exe\" --line %line% \"%file%\"\';\n\n// SciTE\n//~ var editor = \'\"C:\\\\Program Files\\\\SciTE\\\\scite.exe\" \"-open:%file%\" -goto:%line%\';\n\n// EmEditor\n//~ var editor = \'\"C:\\\\Program Files\\\\EmEditor\\\\EmEditor.exe\" \"%file%\" /l %line%\';\n\n// PSPad Editor\n//~ var editor = \'\"C:\\\\Program Files\\\\PSPad editor\\\\PSPad.exe\" -%line% \"%file%\"\';\n\n// gVim\n//~ var editor = \'\"C:\\\\Program Files\\\\Vim\\\\vim73\\\\gvim.exe\" \"%file%\" +%line%\';\n\nvar url = WScript.Arguments(0);\nvar match = /^editor:\\/\\/open\\/\\?file=(.+)&line=(\\d+)$/.exec(url);\nif (match) {\n	var file = decodeURIComponent(match[1]).replace(/\\+/g, \' \');\n	var command = editor.replace(/%line%/g, match[2]).replace(/%file%/g, file);\n	var shell = new ActiveXObject(\"WScript.Shell\");\n	shell.Exec(command.replace(/\\\\/g, \'\\\\\\\\\'));\n}\n\\---\n\n**2. Register \"editor://\" protocol in your system**\n\nCreate and open **`editor.reg`**:\n\nBe careful with backslashes and correct path to handler executable **`run-editor.js`** .[note]\n\n/---\nREGEDIT4\n\n[HKEY_CLASSES_ROOT\\editor]\n@=\"URL:editor Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\editor\\shell\\open\\command]\n@=\"wscript \\\"C:\\\\path\\\\to\\\\run-editor.js\\\" \\\"%1\\\"\"\n\\---\n\n\nLinux\n======\n\n1. **Create \"editor://\" protocol handler in form of a BASH script `run-editor.sh`**.\n\nCreate file **`~/bin/run-editor.sh`**,\n\n/---\ntouch ~/bin/run-editor.sh\n\\---\n\nmake it executable,\n\n/---\nchmod +x ~/bin/run-editor.sh\n\\---\n\nand insert following code:\n\n/---\n#!/bin/bash\n\nurl=\"$1\"\n\nurl=${url#*file=}\nline=${url##*line=}\nfile=${url%%&line*}\nfile=${file//\\%2F/\\/}\n\n# Netbeans\nnetbeans \"$file:$line\"\n# PhpStorm\n#phpstorm --line $line \"$file\"\n# Kate\n#kate --line $line \"$file\"\n# Vim\n#vim \"$file\" +$line\n# Gedit\n#gedit +$line \"$file\"\n# Komodo\n#komodo \"$file#$line\"\n\\---\n\nIf you use Netbeans (or another IDE) not installed from repository, its binary probably won\'t be in $PATH. This can be fixed very easily, just make a symlink to IDE\'s executable in **`~/bin`** directory. .[note]\n\n**2. Register \"editor://\" protocol in your system**\n\nKDE 4\n--------\n\nIn KDE 4 you have to edit a config file **`/usr/share/kde4/services/editor.protocol`** and add this section:\n\n/---\n[Protocol]\nexec=/home/<username>/bin/run-editor.sh \"%u\"\nprotocol=editor\ninput=none\noutput=none\nhelper=true\nlisting=\nreading=false\nwriting=false\nmakedir=false\ndeleting=false\n\\---\n\nGnome\n--------\n\nIn Gnome you can register \"editor://\" protocol by configuration utility:\n\n/---\ngconftool-2 -s /desktop/gnome/url-handlers/editor/command --type String \'/home/<username>/bin/run-editor.sh %s\'\ngconftool-2 -s /desktop/gnome/url-handlers/editor/enabled --type Boolean true\n\\---\n\nfor Vim or another CLI tool also add:\n\n/---\ngconftool-2 -s /desktop/gnome/url-handlers/editor/needs_terminal --type Boolean true\n\\---\n\nBe careful with the path. Shortcut ~/ will NOT work because configuration is system-wide. .[note]\n\nMac OS X\n========\n\nIf you use **TextMate** editor, or another supporting special URL, just configure it in $editor variable. You can use substitutions **`%file`** and **`%line`**:\n\n/---code php\n// TextMate\nDebugger::$editor = \'txmt://open/?url=file://%file&line=%line\';\n// MacVim\nDebugger::$editor = \'mvim://open/?url=file://%file&line=%line\';\n\\---\n\nTroubleshooting:\n===========\n\n- in Firefox you may need to allow custom protocol execution in about:config by setting *network.protocol-handler.expose.editor* or *network.protocol-handler.expose-all*. It should be allowed by default however.\n- If it\'s not all working immediately, don\'t panic. Try to refresh the page, restart browser or computer. That should help.\n\nIn case of more troubles or questions, ask on [forum | http://forum.nette.org/en].\n',	'en',	0,	'public'),
  (78,	10,	'2015-04-24 20:00:13',	'2015-04-24 20:00:13',	3194,	'Jak po odeslání formuláře zobrazit stejnou stránku?',	'jak-po-odeslani-formulare-zobrazit-stejnou-stranku',	'\n.[perex]\nJsme na stránce se článkem a potřebujeme uživatele přihlásit. Máme formulář na více místech a po odeslání chceme na místo původní.\n\nPřesně na to se hodí \"storeRequest\":http://api.nette.org/2.0/source-Application.UI.Presenter.php.html#1115 a \"restoreRequest\":http://api.nette.org/2.0/source-Application.UI.Presenter.php.html#1139, které nám umožní `se vrátit`. V těchto případech Vám odpadnout starosti s přemýšlením nad `$this->redirect(...)`.\n\nPraktickou ukázku **přesměrování na požadovanou stránku po úspěšném přihlášení** naleznete v příkladu \"CD-collection\":https://github.com/nette/examples/tree/v2.2.4/CD-collection/app/presenters v distribuci Nette. Konkrétně:\n\n* \"storeRequest()\":https://github.com/nette/examples/blob/v2.2.4/CD-collection/app/presenters/DashboardPresenter.php#L30\n* \"restoreRequest()\":https://github.com/nette/examples/blob/v2.2.4/CD-collection/app/presenters/SignPresenter.php#L45\n\nZde si ve zkratce ukážeme, jak fungují. Metoda `Nette\\Application\\UI\\Presenter::storeRequest()` uloží aktuální request od uživatele se všemi jeho parametry a vrátí textový klíč, pod kterým jej můžeme opět vyvolat.\n\n`DashboardPresenter` obsluhuje spoustu akcí, které upravují data. Takže na jeho začátku, v metodě `startup` se podíváme, jestli je uživatel přihlášen. Pokud není, tak ho přesměrujeme na `SignPresenter`.\n\n/--php\nclass DashboardPresenter extends BasePresenter\n{\n	protected function startup()\n	{\n		parent::startup();\n\n		if (!$this->user->isLoggedIn()) {\n			if ($this->user->logoutReason === Nette\\Security\\IUserStorage::INACTIVITY) {\n				$this->flashMessage(\'You have been signed out due to inactivity. Please sign in again.\');\n			}\n			$this->redirect(\'Sign:in\', array(\'backlink\' => $this->storeRequest()));\n		}\n	}\n\n	// ...\n}\n\\--\n\n`SignPresenter` obsahuje formulář na přihlášení a jeho zpracování. Také je velice důležitý persistentní parametr `$backlink`, který se nám bude přenášet i přes odeslání formuláře.\n\n/--php\nclass SignPresenter extends BasePresenter\n{\n	/** @persistent */\n	public $backlink = \'\';\n\n	protected function createComponentSignInForm()\n	{\n		$form = new Nette\\Application\\UI\\Form;\n		// políčka formuláře ...\n		$form->onSuccess[] = $this->signInFormSubmitted;\n		return $form;\n	}\n\n	public function signInFormSubmitted($form)\n	{\n		// přihlášení ...\n		$this->restoreRequest($this->backlink);\n		$this->redirect(\'Dashboard:\');\n	}\n\n	// ...\n}\n\\--\n\nMetoda `Nette\\Application\\UI\\Presenter::restoreRequest()` přijímá klíč requestu, který jsme si uložili dříve. Pokud pod klíčem nic nenajde, tak nebude dělat nic a přijde na řadu \"výchozí přesměrování\".\n',	'cs',	0,	'public'),
  (79,	10,	'2015-04-24 20:00:40',	'2015-04-24 20:00:40',	3194,	'Redirect to same page after form submit',	'redirect-to-same-page-after-form-submit',	'.[perex]\nWe\'re on a protected page and we need to force the user to sign in. We have these place all over the application we want the user to get back to where he starter, after signing in.\n\nExactly that is solved by \"storeRequest\":http://api.nette.org/2.0/source-Application.UI.Presenter.php.html#1115 and \"restoreRequest\":http://api.nette.org/2.0/source-Application.UI.Presenter.php.html#1139, which allows us to \"restore request\". In these cases you won\'t have to think about how to redirect back with `$this->redirect(...)`.\n\nYou can have a look at working example in \"CD-collection\":https://github.com/nette/examples/tree/master/CD-collection/app/presenters in Nette Framework distribution. Specifically\n\n* \"`storeRequest()`\":https://github.com/nette/examples/blob/master/CD-collection/app/presenters/DashboardPresenter.php#L26\n* \"`restoreRequest()`\":https://github.com/nette/examples/blob/master/CD-collection/app/presenters/SignPresenter.php#L41\n\nLets examplain really quick how these work. Method `UI\\Presenter::storeRequest()` stores current request from user with all its parametrs and returns textual key, that representes it, and can be used for invoking the request again.\n\n`DashboardPresenter` handles few actions, that edit some data. So on it\'s startup, we will check if the user is logged in. If not, we will redirect him to `SignPresenter`.\n\n/--php\nclass DashboardPresenter extends BasePresenter\n{\n	protected function startup()\n	{\n		parent::startup();\n\n		if (!$this->user->isLoggedIn()) {\n			if ($this->user->logoutReason === Nette\\Http\\UserStorage::INACTIVITY) {\n				$this->flashMessage(\'You have been signed out due to inactivity. Please sign in again.\');\n			}\n			$this->redirect(\'Sign:in\', array(\'backlink\' => $this->storeRequest()));\n		}\n	}\n\n	// ...\n}\n\\--\n\n`SignPresenter` contains login form and it\'s handler. Also wery important persistent parameter `$backlink`, which will automatically persist in the url when the user will submit the login form.\n\n/--php\nclass SignPresenter extends BasePresenter\n{\n	/** @persistent */\n	public $backlink = \'\';\n\n	protected function createComponentSignInForm()\n	{\n		$form = new Nette\\Application\\UI\\Form;\n		// políčka formuláře ...\n		$form->onSuccess[] = $this->signInFormSubmitted;\n		return $form;\n	}\n\n	public function signInFormSubmitted($form)\n	{\n		// přihlášení ...\n		$this->restoreRequest($this->backlink);\n		$this->redirect(\'Dashboard:\');\n	}\n\n	// ...\n}\n\\--\n\nMethod `UI\\Presenter::restoreRequest()` accepts request key, that we\'ve previously stored. If there is no stored request for the given key, it will do nothing and the \"default redirect\" will take care.\n',	'en',	0,	'public'),
  (80,	11,	'2015-04-24 20:01:52',	'2015-04-24 20:01:52',	3194,	'Jak předávat id při editaci záznamu',	'jak-predavat-id-pri-editaci-zaznamu',	'Chcete-li editovat záznam, musíte předat jeho id ukládající funkci. Můžete k tomu sice použít `$form->addHidden()`, ve většině případů je ale vhodnější použít parametr akce.\n\n.[warning]\nNejdůležitějším poznatkem z celého kódu je však fakt, že práva k záznamu se musí kontrolovat i v akci, i v signálu. Odeslání formuláře je také signál (přistupný z url).\n\n\n/---php\nuse Nette\\Application\\UI\\Form;\nuse Nette\\Application\\BadRequestException;\nuse Nette\\Application\\ForbiddenRequestException;\n\nclass RecordPresenter extends BasePresenter\n{\n	/** @var object */\n	private $record;\n\n	/**\n	 * Edit record\n	 */\n	public function actionEdit($id = 0)\n	{\n		// načtení záznamu z databáze\n		$this->record = $this->model->records->fetch($id);\n\n		if (!$this->record) { // kontrola existence záznamu\n			throw new BadRequestException;\n\n		} elseif ($this->record->userId != $this->user->id) { // kontrola oprávnění\n			throw new ForbiddenRequestException;\n		}\n\n		$this[\'recordForm\']->setDefaults($this->record); // nastavení výchozích hodnot\n	}\n\n	/**\n	 * Form to edit record\n	 */\n	protected function createComponentRecordForm()\n	{\n		$form = new Form;\n		$form->addText(\'myValue\', \'Name:\', 20, 60);\n		$form->addSubmit(\'send\', \'Send\');\n		$form->onSuccess[] = callback($this, \'recordUpdate\');\n		return $form;\n	}\n\n	/**\n	 * Record update\n	 * @form recordForm\n	 */\n	public function recordUpdate(Form $form)\n	{\n		if (!$this->record) { // kontrola existence záznamu\n			throw new BadRequestException;\n		}\n\n		$values = $form->getValues();\n		$this->model->records->update($this->record->id, $values);\n\n		$this->flashMessage(\'Record updated!\', \'success\');\n		$this->redirect(\'edit\');\n	}\n}\n\\---\n\n\n.[tip]\nDalším krokem může být vyčlenění získání záznamu [do samostatné metody | vychozi-data-pro-editacni-formular].\n\n\nStejný formulář pro přidání i uložení záznamu\n===\n\nTedy pro jeden formulář pro více akcí je třeba upravit výše uvedený kód takto:\n\n/--php\n\n\n/**\n * Form to manage record\n */\nprotected function createComponentRecordForm()\n{\n	// ...\n	$form->onSuccess[] = callback($this, \"processRecordForm\");\n	// ...\n}\n\n/**\n * Record process\n * @form recordForm\n */\npublic function processRecordForm(Form $form)\n{\n	if ((int) $this->getParameter(\'id\') && !$this->record) { // kontrola existence záznamu pouze v případe editace\n		throw new BadRequestException;\n	}\n\n	$values = $form->getValues();\n\n	if($this->record) { // upravujeme záznam\n		$this->model->records->update($this->record->id, $values);\n		$this->flashMessage(\"Record updated!\", \"success\");\n		$this->redirect(\"edit\");\n	} else { // přidáváme záznam\n		$this->model->records->insert($values);\n		$this->flashMessage(\"Record inserted!\", \"success\");\n		$this->redirect(\"default\");\n	}\n}\n\\--\n',	'cs',	0,	'public'),
  (81,	11,	'2015-04-24 20:04:58',	'2015-04-24 20:04:58',	3194,	'Record editing and passing id to form',	'record-editing-and-passing-id-to-form',	'If you want to edit a record, you have to pass its id to save function. You can use `$form->addHidden()` though, but often it\'s better to use an action parameter.\n\n.[warning]\nMost important is fact, that **permissions to edit the record have to be check both in the action and the signal**. Record submit is signal as well (accessible by url).\n\n\n/---php\nuse Nette\\Application\\UI\\Form;\nuse Nette\\Application\\BadRequestException;\nuse Nette\\Application\\ForbiddenRequestException;\n\nclass RecordPresenter extends BasePresenter\n{\n	/** @var object */\n	private $record;\n\n	/**\n	 * Edit record\n	 */\n	public function actionEdit($id = 0)\n	{\n		// fetch record from database\n		$this->record = $this->model->records->fetch($id);\n\n		if (!$this->record) { // check if record exits\n			throw new BadRequestException;\n\n		} elseif ($this->record->userId != $this->user->id) { // check permissions to edit\n			throw new ForbiddenRequestException;\n		}\n\n		$this[\'recordForm\']->setDefaults($this->record); // set up default values\n	}\n\n	/**\n	 * Form to edit record\n	 */\n	protected function createComponentRecordForm()\n	{\n		$form = new Form;\n		$form->addText(\'myValue\', \'Name:\', 20, 60);\n		$form->addSubmit(\'send\', \'Send\');\n		$form->onSuccess[] = callback($this, \'recordUpdate\');\n		return $form;\n	}\n\n	/**\n	 * Record update\n	 * @form recordForm\n	 */\n	public function recordUpdate(Form $form)\n	{\n		if (!$this->record) { // check if the record exists\n			throw new BadRequestException;\n		}\n\n		$values = $form->getValues();\n		$this->model->records->update($this->record->id, $values);\n\n		$this->flashMessage(\'Record updated!\', \'success\');\n		$this->redirect(\'edit\');\n	}\n}\n\\---\n\n\n.[tip]\nNext step could be creating [separate function|  cs:vychozi-data-pro-editacni-formular] for checking both record existence and rights.\n\n\nSave & update form in one\n===\n\nIn other word one form for multiple actions.\n\n/--php\n\n\n/**\n * Form to manage record\n */\nprotected function createComponentRecordForm()\n{\n	// ...\n	$form->onSuccess[] = callback($this, \'processRecordForm\');\n	// ...\n}\n\n/**\n * Record process\n * @form recordForm\n */\npublic function processRecordForm(Form $form)\n{\n	if ((int) $this->getParameter(\'id\') && !$this->record) { // check if the record exists only while being edited\n		throw new BadRequestException;\n	}\n\n	$values = $form->getValues();\n\n	if($this->record) { // we\'re editing record\n		$this->model->records->update($this->record->id, $values);\n		$this->flashMessage(\'Record updated!\', \'success\');\n		$this->redirect(\'edit\');\n	} else { // we\'re adding new record\n		$this->model->records->insert($values);\n		$this->flashMessage(\'Record created!\', \'success\');\n		$this->redirect(\'default\');\n	}\n}\n\\--\n',	'en',	0,	'public'),
  (82,	0,	'2015-04-24 20:12:32',	'2015-04-24 20:12:32',	3194,	'Different layout in administration',	'different-layout-in-administration',	'1. one-presenter administration, `AdminPresenter.php`\n=====\n\nHandful for simple and small administration.\n\n\nDirectory structure\n---\n\n/---\n<b>app/\n	models/\n	presenters/\n		AdminPresenter.php\n		BasePresenter.php\n		HomepagePresenter.php\n	templates/\n		Admin/\n			default.latte\n		Homepage/\n			default.latte\n		@layout.latte</b>	← basic layout\n			<b>@layoutAdmin.latte</b>	← admin layout\n	<b>bootstrap.php</b>\n\\---\n\na) templates/Admin/default.latte\n---\n\n/---html\n<!-- use adminLayout.latte -->\n{layout \"../@layoutAdmin.latte\"}\n\n\\--\n\nb) or we can modify structure like this:\n---\n\n/--\n<b>templates/\n	Admin/\n		default.latte\n		@layout.latte\n	Homepage/</b>\n	    ...\n	<b>@layout.latte</b>\n\\--\n\nand template `Admin/@layout.latte` will load for `AdminPresenter.php` automatically.\nSee \"automatic layout loader\":doc:presenters#toc-templates\n\n\nc) or AdminBasePresenter\n---\n\nWe still have `@layoutAdmin.latte` as in variant *A*\n\n/--php\nabstract class AdminBasePresenter extends BasePresenter\n{\n	protected function beforeRender()\n	{\n		parent::beforeRender();\n		$this->setLayout(\'layoutAdmin\');\n	}\n}\n\\--\n\n\n2. Modules - Front & Admin\n---\n\nDivide application to two separated modules with their own `@layout.latte`.\n\nSee \"MVC Applications & Presenters\":doc:presenters#toc-modules\n',	'en',	0,	'public'),
  (83,	0,	'2015-04-24 20:12:53',	'2015-04-24 20:12:53',	3194,	'Simple ajax example',	'simple-ajax-example',	'\n.[note]\nThis tutorial builds on **Nette 2.0.10** sandbox.\n\n\nSetup\n===\n\nFirst, we download [Nette|www:download] and use content of `sandbox` folder as base for our tutorial.\n\nThan we need to link \"Nette Ajax addon\":http://addons.nette.org/cs/nette-ajax-js. Lets download current version of \"nette.ajax.js\":https://github.com/vojtech-dobes/nette.ajax.js. Place it to `www/js` folder.\n\n\n**Templates/@layout.latte**\n\n/--html\n{block scripts}\n<script src=\"{$basePath}/js/jquery.js\"></script>\n<script src=\"{$basePath}/js/netteForms.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script> {* Nette Ajax depens on jQuery *}\n<script src=\"{$basePath}/js/main.js\"></script>\n{/block}\n\\--\n\nThan we initiate Nette Ajax in `main.js`:\n\n/--js\n$(function () {\n    $.nette.init();\n});\n\\--\n\nSimple `$.nette.init()` enables link and form ajaxization via class `.ajax`. To get more info see \"usage\":https://github.com/vojtech-dobes/nette.ajax.js#usage on addon page.\n\n\nIn presenter\n===\n\nThis is the most simple use of Nette Ajax. Here we go!\n\n**HomepagePresenter.php**\n\n/--php\nclass HomepagePresenter extends BasePresenter\n{\n	/** @var string */\n	private $anyVariable;\n\n\n	public function handleChangeVariable()\n	{\n		$this->anyVariable = \'changed value via ajax\';\n		if ($this->isAjax()) {\n			$this->invalidateControl(\'ajaxChange\');\n		}\n	}\n\n\n	public function renderDefault()\n	{\n		if ($this->anyVariable === NULL) {\n			$this->anyVariable = \'default value\';\n		}\n		$this->template->anyVariable = $this->anyVariable;\n	}\n\n}\n\n\\--\n\n\nTo change value in template we need to use special property `$anyVariable`. If we would use `$this->template->anyVariable = \'...\'` both in `handle*` and `render*`, only `render*` would matter, see \"life cycle of presenter\":doc:presenters#toc-life-cycle-of-presenter.\n\n**Homepage/default.latte**\n\n/--html\n<div id=\"content\">\n	{snippet ajaxChange}\n		{$anyVariable}\n	{/snippet}\n\n	<a n:href=\"changeVariable!\" class=\"ajax\">Change variable!</a>\n</div>\n\\--\n\nNow just go and click on **Change variable!** link. *default value* should change to \"changed value via ajax\".\n\n\nIn component\n===\n\nIf you want to use ajax in component, you can check \"ajax in documentation\":doc:ajax.\n\n/---comment\nFix quickstart:ajax to en version when ready\n\\---',	'en',	0,	'public'),
  (84,	0,	'2015-04-24 20:14:00',	'2015-04-24 20:14:00',	3073,	'Návod jak vytvořit blog',	'navod-jak-vytvorit-blog',	'.[perex]\nBlog, to je dnes už webová klasika, \"hello world\" všech webových řešení. Pojďme se v rychlosti podívat na to, jak takový jednoduchý blog vytvořit v Nette.\n\nPožadavky\n===\n\n- Pochopení základních principů Nette (vztahy v MVP vzoru, základní představa o funkci presenteru a jeho vztahu k šablonám)\n- Povrchní znalost [dibi | http://dibiphp.com]\n- [Prostředí pro běh Nette | doc:requirements]\n\nÚvod\n===\n	Tvorba jednoduchého blogu je evergreenem mezi tématy tutoriálů různých webových frameworků. Bohužel, většina tutoriálů je okleštěna na minimální kostru úkolu a jako hlavní cíl si kladou ukázat uživateli, jak jednoduše to s daným frameworkem jde. Tím se náročnost úlohy snižuje na úroveň, na které téměř nestojí za to nějaký framework používat. Neberte tedy tento tutoriál jako lákaldo na Nette, ale jako výukový materiál.\n	V tutoriálu je použita namespacová verze Nette. Přestože aplikace je tak malá, že namespaces jsou tu spíš na obtíž, je to něco, co by každý potenciální uživatel Nette měl znát a umět používat. Pokud z technických důvodů nemůžete použít verzi pro PHP =>5.3, použijte bezprefixovou verzi Nette pro PHP 5.2 a vypusťte z uvedených zdrojových kódu definice namespaces.\n\nBlog za 19 minut!\n-----------------\n	Pomocí [RoR | http://rubyonrails.org] nebo [CodeIgniteru | http://codeigniter.com/] lze vytvořit „kompletní“ „blog“ za „20“ minut. Vážení, to nic není! Předvedu Vám, že s Nette to za 19 minut dokážete i Vy!\n\nInstalace\n=========\n	Použijeme skeleton z  ditribuce. Nakopírujte ho do požadované složky na serveru. Do složky `/libs` nakopírujeme \"dibi\":http://dibiphp.com/ (v distribuci Nette se nachází ve složce 3rdParty). Budeme také potřebovat databázi, já se budu držet MySQL, ale pokud chcete použít SQLite nebo PostgreSQL, není to problém, stačí číst dál.\n\nNezapomeňte, že ve skeletonu chybí Nette ve složce `/libs`! .[note]\n\n\nDatabáze a model\n===============\nZačněmě s tvorbou příslušných tabulek. Jejich struktura je jasná ze zadání. Spustíme tedy na naši databázi tyto příkazy:\n/--code sql\nCREATE TABLE `posts` (\n	`id` int(11) NOT NULL AUTO_INCREMENT,\n	`title` varchar(128) COLLATE utf8_bin NOT NULL,\n	`body` text COLLATE utf8_bin NOT NULL,\n	`date` datetime NOT NULL,\n	PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_bin;\n\\--\n\nTím vytvoříme tabulku s články.\n\n/--code sql\nCREATE TABLE `comments` (\n	`id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY ,\n	`post_id` INT NOT NULL ,\n	`author` VARCHAR( 128 ) NOT NULL ,\n	`body` TEXT NOT NULL ,\n	`date` DATETIME NOT NULL,\n	INDEX (post_id),\n	FOREIGN KEY (post_id) REFERENCES posts(id)\n) ENGINE = INNODB CHARACTER SET utf8 COLLATE utf8_bin;\n\\--\n\nA tímto (překvapivě) tabulku komentářů.\n\nPokud používáte jinou databázi, vytvořte stejnou strukturu tabulek, dibi se postará o kompatibilitu na straně aplikace samo. .[note]\n\nKdyž máme databázi, je potřeba se k ní skrz dibi připojit. Konfigurační soubory v Nette nabízejí elegantní způsob správy dat jako jsou údaje o databázi. Otevřete si `config.ini` ve složce `/app` a do části `[common]` přidejte **příslušnou modifikaci** těchto řádků:\n\n/--code ini\ndb.server = localhost\ndb.database = blogtut\ndb.username = blogtut\ndb.password = blogtut\ndb.driver = mysqli\ndb.charset = utf8\ndb.lazy = TRUE\n\\--\n\nA nyní připojení samotné. Do souboru `bootstrap.php` (zaváděcí soubor celé aplikace, jak už byste měli vědět) přidejte před řádek\n/--code php\n$application->run(); // Tento řádek spustí naši aplikaci...\n\\--\ntoto:\n/--code php\ndibi::connect(Environment::getConfig(\'db\')); // ...a připojit se potřebujeme před spuštěním aplikace\n\\--\n\nZde se na chvíli zastavíme a dáme si minutku teorie, ve které prohloubíme znalosti a odpovíme na možné otázky. Několik zásadních bodů:\n- Nette [načítá soubory s kódem (ať už knihovny nebo části aplikace samotné) samo a dle potřeby | doc:nette-loaders]. Proto není žádný include či require ani tady, ani nikde jinde v našem kódu.\n- Voláním `Environment::getConfig(\'db\')` jsme z konfiguračního souboru získali pole určující nastavení databáze. Náš zápis je jiná reprezentace asociativního pole\n/--code php\n$db = array(\n	\'server\' => \'localhost\',\n	\'database\' => \'blogtut\',\n	\'username\' => \'blogtut\',\n	\'password\' => \'blogtut\',\n	\'driver\' => \'mysql\',\n	\'charset\' => \'utf8\',\n	\'lazy\' => TRUE\n);\n\\--\n- I když spojení s databází nastavujeme pokaždé, když se aplikace spustí, skutečné spojení probíhá jen tehdy, kdy je to skutečně potřeba, a to díky nastavení `db.lazy = TRUE` v `config.ini`.\n\nMusíme ještě vytvořit modely pro obě tabulky.\n\n/--code php\n<?php\n\nclass PostsModel\n{\n	public static function fetchAll()\n	{\n		return dibi::fetchAll(\'\n			SELECT *\n			FROM [posts]\n			ORDER BY [date]\', dibi::DESC\n		);\n	}\n}\n\\--\n\n/--code php\n<?php\n\nclass CommentsModel\n{\n	public static function fetchAll($post_id)\n	{\n		return dibi::fetchAll(\'\n			SELECT *\n			FROM [comments]\n			WHERE [post_id] = %i\', $post_id\n		);\n	}\n}\n\n\\--\n\nPro srozumitelnost budou prozatím jejich metody bez zbytečných ohledů tahat všechna dostupná data. Oba soubory s definicí tříd uložte do složky `/app/models` a pojmenujte je podle třídy, kterou obsahují (`PostsModel.php`, `CommentsModel.php`).\n\nPokud jste zvyklí ukončovat skripty značkou `?>`, tak **si rychle odvykněte!** Ukončovací tagy jsou nepovinné a způsobují pouze problémy s netisknutelnými znaky, což poté způsobí nemožnost odeslání HTTP hlaviček. .[caution]\n\nPresenter\n=========\n	V `/app/presenters/` je HomepagePresenter. Ten poslouží jako dobrý základ našeho snažení. Přidáme do něj metodu, která vezme data z modelu a předá je do template k vykreslení.\n	Metodu renderDefault upravíme na\n/--code php\npublic function renderDefault()\n{\n	$this->template->posts = PostsModel::fetchAll();\n}\n\\---\n\n	Pokud si nejste jistí, proč pracuji s metodou default v presenteru Homepage, podívejte se na [routy | doc:nette-application-route] v souboru bootstrap.php. .[tip]\n\nView\n=====\n	Výborně, teď máme v view `default` dostupnou proměnnou `$posts`, která obsahuje všechny příspěvky. Pojďme je vypsat.\n	Ve složce `/app/templates` je soubor `@layout.phtml`. Ten obsahuje základní rámec všech stránek, které budeme tvořit. Proto doporučuji si ho prohlédnout.\n	V `/app/templates/Homepage` je soubor `default.phtml`, který obsahuje definici bloku `content`, jehož obsah nahradí `{include #content}` v layoutu. Výpis všech článků může vypadat třeba takhle:\n/--code html\n{block content}\n<h1>Můj blogísek</h1>\n<div id=\"posts\">\n	{if count($posts)}\n		{foreach $posts as $post}\n		<div class=\"post\">\n			<h3>{$post[\'title\']}</h3>\n			<small>Přidáno {$post[\'date\']|date}</small>\n			<p>{$post[\'body\']}</p>\n		</div>\n		{/foreach}\n	{else}\n		Zatím nebyl napsán žádný článek.\n	{/if}\n</div>\n\\--\n\nStáhněte si [testovací data | attachment:posts.sql], nahrajte je do databáze a zkuste otevřít root webu ve vašem prohlížeči. Výsledek by měl vypadat takto:\n\n[* screen1.jpeg *]\n\nDovolím si zkazit radost povinnou trochou teorie:\n- Použité příkazy ve složených závorkách se nazývají makra [Latte filtru | doc:/sablony/latte-filter] a víc se o nich dozvíte v dokumentaci.\n- Všiměte si části `{$post[\'date\']|date}`. Ono date za vertical barem (svislítkem, chcete-li) je [helper | doc:/sablony/helpers]. Helper je jednoduchá funkce, která provádí s dannou proměnnou nějakou operaci podstatnou pouze pro zobrazení.\n\nKomentáře\n=========\n	To ani nebolelo a zabralo to jen pár minut, ale blog je o komunikaci s lidmi. Proto potřebujeme přidat možnost komentovat příspěvky. Klasiciký přístup je takový, že na titulní straně se zobrazuje jen začátek textu s odkazem na celý text, kde je i možnost komentovat. Pojďme tedy na to.\nNová metoda presenteru\nProtože zobrazení samostatného příspěvku nijak nesouvisí s titulní stranou, přidáme do našeho preseneru novou metodu:\n/--code php\npublic function renderSingle($id = 0)\n{\n	$this->template->post = PostsModel::fetchSingle($id);\n}\n\\--\n\nA vytvoříme příslušnou metodu v PostsModel:\n\n/--code php\npublic static function fetchSingle($id)\n{\n	return dibi::fetch(\'\n		SELECT *\n		FROM [posts]\n		WHERE [id] = %i\', $id\n	);\n}\n\\--\n\nMěli byste znát rozdíl mezi `dibi::fetchAll` a `dibi::fetch`. První vrací kolekci [DibiRow | http://api.dibiphp.com/1.3/DibiRow.html], která implementuje [ArrayAccess | http://php.net/manual/kr/class.arrayaccess.php], druhá vrací přímo `DibiRow`. .[note]\n\n	Samozřejmě není optimální pro každý typ požadavku psát samostatnou funkci v modelu, máme na to různé fígly, ale prozatím <abbr title=\"Keep it simple, stupid!\">KISS</abbr>.\n\n	Také musíme vytvořit template pro tento požadavek, takže do `/app/templates/Homepage/single.phtml` vložíme:\n/--code html\n{block content}\n<div class=\"post\">\n	<h1>{$post[\'title\']}</h1>\n	<small>Přidáno {$post[\'date\']|date}</small>\n	<p>{$post[\'body\']}</p>\n</div>\n\\--\nNyní můžete v prohlížeči zkusit otevřit třeba `/Homepage/single/2`.\n\n[* screen2.jpeg *]\n\nOpět se vracíme k routám. Podívejte se ještě jednou do `bootstrap.php`. .[tip]\n\nOdkazy\n------\nAby se sem dostal i běžný uživatel, potřebujeme nějaké odkazy z hlavní stránky. K tomu slouží makro [{llink …} | http://doc.nette.org/cs/generovani-odkazu]. Předělejme tedy view titulní stránky:\n\n/--code html\n{block content}\n<h1>Můj blogísek</h1>\n<div id=\"posts\">\n	{if count($posts)}\n		{foreach $posts as $post}\n		<div class=\"post\">\n			<h3>{$post[\'title\']}</h3>\n			<small>Přidáno {$post[\'date\']|date}</small>\n			<p>{$post[\'body\']|truncate:300}</p>\n			<a href=\"{link single $post[\'id\']}\">Více…</a>\n		</div>\n		{/foreach}\n	{else}\n		Zatím nebyl napsán žádný článek.\n	{/if}\n</div>\n\\--\n\n[* screen3.jpeg *]\n\nV naší pravidelné minutovce teorie bych nyní rád vyzdvihl dvě věci:\n- Všimněte si helperu `truncate:300` a jeho efektu.\n- Zápis `{plink single $post[\'id\']}` znamená: vytvoř odkaz na akci single aktuálního presenteru a přidej parametr `$post[\'id\']`. Je ekvivalentní se zápisem `{plink Homepage:single $post[\'id\']}`. Je důležité, že nezapisujeme žádné URL, ale odkaz na akci presenteru.\n- URL je zpětně vytvořeno tak, aby odpovídalo routám v `bootstrap.php` a naše aplikace je tím pádem na jeho tvaru naprosto nezávislá.\n\nFormulář\n--------\nKonečně se dostáváme k něčemu „záživnějšímu“ - pojďme si vytvořit formulář na odesílání komentářů! Nette má několik způsobů jak řešit formuláře, od tvrdého nakódování do templatu a odděleného zpracování vstupů po sofistikované metody jako [AppForm | doc:nette-application-appform].\nTřída `AppForm` nabízí výhody, o kterým se mnohým ani nesnilo. Náš formulář bude samostatnou komponentou. Pokud jde o tvorbu komponent, používá [„továrničky“ | doc:nette-application-presenter#toc-tovarnicky-na-komponenty], které vyrobí komponentu až v momentě, kdy je to skutečně potřeba.\nDo `HomepagePresenter` přidáme klauzuli `use` a dvě funkce:\n/--code php\nuse Nette\\Application\\AppForm;\n\\--\n/--code php\npublic function createComponentCommentForm($name)\n{\n	$form = new AppForm($this, $name);\n	$form->addText(\'author\', \'Jméno\')\n			->addRule(AppForm::FILLED, \'To se neumíš ani podepsat?!\');\n	$form->addTextArea(\'body\', \'Komentář\')\n			->addRule(AppForm::FILLED, \'Komentář je povinný!\');\n	$form->addSubmit(\'send\', \'Odeslat\');\n	$form->onSubmit[] = callback($this, \'commentFormSubmitted\');\n	return $form;\n}\n\npublic function commentFormSubmitted(AppForm $form)\n{\n	$data = $form->getValues();\n	$data[\'date\'] = new DateTime();\n	$data[\'post_id\'] = (int) $this->getParam(\'id\');\n	$id = CommentsModel::insert($data);\n	$this->flashMessage(\'Komentář uložen!\');\n	$this->redirect(\"this#comment-$id\");\n}\n\\--\n	První z nich zpracovává odeslaný formulář (všimněte si přesměrování, které zajistí, aby uživatel neodeslal formulář vícekrát kliknutím na tlačítko Obnovit), druhá je zmíněná továrnička.\n\n	Za pozornost stojí volání \'$this->flashMessage(\'Komentář uložen!\')\'. Nette obsahuje tzv. flash zprávičky, což jsou krátké zprávy které uživatele informují o aktuálním stavu aplikace. Defaultně jsou vypisovány v \'@layout.phtml\'.\n\n	Do CommentsModel musíme přidat použitou metodu:\n/--code php\npublic static function insert($data)\n{\n	dibi::query(\'\n		INSERT INTO [comments]\', $data\n	);\n\n	return dibi::getInsertId();\n}\n\\--\n\n	A také nesmíme zapomenout předat všechny komentáře k příslušnému příspěvku do šablony, takže metodu `renderSingle` upravíme:\n\n/--code php\npublic function renderSingle($id = 0)\n{\n	if (!($post = PostsModel::fetchSingle($id))) {\n		$this->redirect(\'default\'); //pokud clanek neexistuje, presemerujeme uzivatele\n	}\n	$this->template->post = $post;\n	$this->template->comments = CommentsModel::fetchAll($id);\n}\n\\--\n\n	Poslední věc, která zbývá, je úprava naší šablony:\n/--code html\n{block content}\n<a href=\"{link default}\">&lt;&lt; home </a>\n<div class=\"post\">\n    <h1>{$post[\'title\']}</h1>\n    <small>Přidáno {$post[\'date\']|date}</small>\n    <p>{$post[\'body\']}</p>\n</div>\n\n<h3>Komentáře:</h3>\n<div id=\"comments\">\n	{if count($comments)}\n    		<div id=\"comment-{$comment->id}\" class=\"commment\" n:foreach=\"$comments as $comment\">\n        		<p>{$comment[\'body\']}</p>\n        		<small>{$comment[\'author\']}, {$comment[\'date\']|date}</small>\n        		<hr>\n    		</div>\n	{else}\n		Ke článku zatím nebyly napsány žádné komentáře. Buďte první!\n	{/if}\n</div>\n\n{control commentForm}\n\\--\nAle pozor! Tady jaksi chybí `{foreach ...}`, že? Místo něho jsou použity tzv. [\"n-atributy\"|doc:/cs/sablony/latte-filter#toc-alternativni-zapis-pomoci-n-atributu], které v některých případech nabízejí alternativní syntaxy zápisu Latté maker.\n\nVšimněte si, že formulář si sám najde cestu do šablony a vykreslí se. Zkuste odeslat formulář nevyplněný. Jak vidíte, Nette vygenerovalo validační Javascript k našemu formuláři. Ale validace probíhá i na straně serveru, takže vypnutý Javascript její funkčnost neovlivní.\n\nVe starších příkladech se místo makra `control` můžete setkat s jeho starším aliasem `widget`. .[note]\n\n[* screen4.jpeg *]\n\nVýsledný zdrojový kód je ke stažení [zde | https://github.com/PJK/Nette-Blog-Tutorial/zipball/master].\n\nDoufám, že jste se něco přiučili. Pokud už se v Nette trochu vyznáte a chcete další náměty, zkuste:\n- Vypsat počet příspěvků/komentářů na hlavní stránku\n- Přidat pár statických stránek a odkazy na ně\n- Vytvořit jednoduchou administraci\n- Zprovoznit stránkování příspěvků pomocí [VisualPaginator | addons:cs/visualpaginator]\n- K administraci přidejte [uživatelské účty | doc:autentizace]\n- Přidat různé typy účtů, kontrolu oprávnění pomocí [ACL | doc:access-control#Permission ACL]\n- Upravit routování a generovat „cool URL“\nSám se těmto úlohám budu věnovat v budoucích tutoriálech.\n\nStáhněte si zdrojový kód: https://github.com/PJK/Nette-Blog-Tutorial/zipball/master .[download]\n',	'cs',	0,	'public'),
  (85,	0,	'2015-04-24 20:15:00',	'2015-04-24 20:15:00',	2651,	'Statický web v Nette',	'staticky-web-v-nette',	'\n.[perex]\nTento tutorial vám předvede, jak v Nette udělat jednoduchý web o 3 stránkách s jednoduchým menu pro jeho ovládání.\n\n.[tip]\nPro verzi **Nette 2 beta pro PHP 5.3** (2011-07-02).\n\nCo budete potřebovat?\n===\n- `sandbox` z aktuální distribuce Nette\n\nCo se naučíte?\n===\n- pracovat se sandboxem (adresářovou strukturou aplikace)\n- vytvořit Presentery a šablony aplikace\n- vytvořit jednoduché menu a přiřadit k němu odkazy\n- připojit CSS styly k aplikaci\n- vytvořit jednoduchou statickou prezentaci\n\n\nAdresářová struktura\n===\nJe dobré si předem připravit adresářovou strukturu, kde bude vaše aplikace sídlit. Tu je vhodné logicky rozčlenit podle architektury [Model-View-Presenter (MVP)|doc:model-view-presenter]. S tím si nemusíte lámat hlavu, protože v distribučním balíčku najdete adresář `sandbox`, kde je již připravená adresářová struktura pro naši aplikaci.\n\n.[tip]\nPokud se s Nette setkáváte poprvé, projděte si **[Quickstart|doc:quickstart/getting-started#toc-obsah-sandboxu]**, který přehledně popisuje základní mechanismy Nette na konkrétní aplikaci.\n\nNyní si můžete zkusit spustit aplikaci.\n\n[* scr2.png *] *** Pokud vás prohlížeč zobrazil uvítací obrazovku frameworku, je vše v pořádku a můžeme se pustit do našeho webu. V opačném případě zkuste [FAQ|faq] nebo [forum|http://forum.nette.org/cs/]\n\n\nVytvoření základního Presenteru\n===\nV první řade je potřeba seznámit se s procesem návrhu [Presenter/View(Action)|http://phpfashion.com/navrh-struktury-presenters-views] a životním cyklem [presenteru|doc:presenters].\n\nMy se budeme držet modelu, kdy si pro každou stránku vytvoříme vlastní Presenter, protože tušíme, že naše webová prezentace se bude v budoucnu rozšiřovat. Tomu však předchází vytvoření abstraktního presenteru. Pokud je vše jasné, vytvoříme ho - `BasePresenter.php`. Je to základní stavební kámen pro ostatní Presentery a bude vypadat takto:\n\n`app/presenters/BasePresenter.php`\n/--php\nuse Nette\\Application\\UI\\Presenter;\n\nabstract class BasePresenter extends Presenter\n{\n\n}\n\\--\n\nNáš web bude mít 3 stránky s menu: `Domů | Nabídka | Kontakt`, budeme tedy potřebovat 3 presentery a to: `HomepagePresenter.php`, `ProductPresenter.php`, `ContactPresenter.php`. My si ukážeme, jak udělat `HomepagePresenter.php` a další 2 už zvládnete sami.\n\n`app/presenters/HomepagePresenter.php`\n/--php\nclass HomepagePresenter extends BasePresenter\n{\n\n}\n\\--\n\nCo je zde důležité? Třida `HomepagePresenter`, tím, že je definována, automaticky hledá šablony `app/templates/@layout.latte` a `app/templates/Homepage/default.latte`\n\nVytvoření základní šablony (@layout.latte)\n===\nNette Framework hledá vždy základní šablonu v umístění `app/templates/` pod názvem `@layout.latte`. Je to výchozí šablona, do které se pak nahrávají další podšablony/bloky.\n\nTakže pokud máme vytvořenou nějakou obecnou/grafickou šablonu, stačí ji přejmenovat, správně umístit a Nette se postará o její zobrazení.\n\nAby tato šablona měla praktický význam a mohla spolupracovat s ostatními, musíme jí vyznačit místa, kde se bude vykreslovat a kam se vloží obsah jiné šablony, případně šablon.\n\nV šablonách lze používat i různé filtry a teď právě nastala vhodná chvíle pro využití  [filtru Latte|doc:templating], díky němuž se nám zjednoduší a zpřehlední zápis PHP kódu. Následující script Vám ukáže, jak označit místa, kam se bude vkládat obsah jiných šablon a jak vypadá zápis s využitím filtru Latte:\n\n`app/templates/@layout.latte`\n/--html\n<!DOCTYPE html>\n<html>\n<head>\n	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n\n	<meta name=\"description\" content=\"Nette Framework Static Web\">\n	<meta name=\"robots\" content=\"{$robots}\" n:ifset=\"$robots\">\n\n	<title>{include #title}</title>\n\n	<link rel=\"stylesheet\" media=\"screen,projection,tv\" href=\"{$basePath}/css/screen.css\" type=\"text/css\">\n	<link rel=\"stylesheet\" media=\"print\" href=\"{$basePath}/css/print.css\" type=\"text/css\">\n	<link rel=\"shortcut icon\" href=\"{$basePath}/favicon.ico\" type=\"image/x-icon\">\n\n	<script type=\"text/javascript\" src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js\"></script>\n	<script type=\"text/javascript\" src=\"{$basePath}/js/netteForms.js\"></script>\n	{block head}{/block}\n</head>\n\n<body>\n<div id=\"header\">\n	<h1>Nette Fabrika, s.r.o.</h1>\n\n	<h2>Otevřeli jsme továrnu na sny...</h2>\n</div>\n	<!--vložení bloku content-->\n	{include #content}\n\n</body>\n</html>\n\\--\n\nNyní musíme ještě vytvořit šablonu pro HomepagePresenter a další 2 presentery, které jste vytvořili samostatně. Pro tento presenter Nette očekává šablonu v adresáři `app/templates/Homepage` pod názvem `default.latte`. Tady je její podoba:\n\n`app/templates/Homepage/default.latte`\n/--html\n{block title}\n	<title>Nette Fabrika, s.r.o. - Úvod</title>\n{/block}\n\n{block content}\n	<div>\n		<p>Vítejte v Nette Fabrice!</p>\n	</div>\n{/block}\n\\--\n\nTo je důležité, protože název adresáře `Homepage` nám vlastně páruje tuto šablonu s `HomepagePresenterem`, který jsme si před malou chvílí vytvořili. V případě jiného pojmenování a nedodržení párování by došlo k chybě. Stejný problém vznikne, pokud pojmenujeme šablonu jinak, než `default.latte`.\n\nVytvoření menu\n===\nK vytvoření menu upravíme šablonu `@layout.latte` v místě, kde menu chceme mít zobrazené:\n\n/--html\n<ul n:inner-foreach=\"$menuItems as $item => $link\">\n	<li>{$item}</li>\n</ul>\n\\--\nTím je úprava základní šablony hotová. Teď stačí v BasePresenteru nachystat data pro proměnnou `$menuItems`.\n\n`app/presenters/BasePresenter.php`\n/--php\nabstract class BasePresenter extends Presenter\n{\n\n	public function beforeRender()\n	{\n		parent::beforeRender(); // nezapomeňte volat metodu předka, stejně jako u startup()\n		$this->template->menuItems = array(\n			\'Domů\' => \'Homepage:\',\n		 	\'Produkty\' => \'Products:\',\n			\'Kontakty\' => \'Contacts:\',\n		);\n	}\n\n}\n\\--\nDefinici proměnné je třeba umístit do metody `beforeRender()`, aby byla dostupná pro všechny view.\n\nDoplnění odkazů z menu\n===\n\n.[note]\nNette Framework vnímá linky/odkazy jako pokyny k nějaké akci, přesněji řečeno kliknutím na odkaz spustíte nějakou funkci/metodu.\nV praxi to znamená, že se vůbec nestaráte o URL odkazu, link totiž volá metodu a je tak na URL nezávislý\n\nMy jednoduše upravíme šablonu `@layout.latte` s použitím filtru Latte:\n\n/--html\n<ul n:inner-foreach=\"$menuItems as $item => $link\">\n	<li><a n:href=\"$link\">{$item}</a></li>\n</ul>\n\\--\n\nPřipojení CSS stylu k šabloně\n===\nNa chvilku si oddechneme a budeme se trochu věnovat grafice. Tzn. nastylujeme si již vytvořené položky v šabloně pomocí CSS. Můžete použít připravený styl v zazipované aplikaci (dole na stránce) a umístit je do `www/css/screen.css`\nNyní připojíme tento styl k naší šabloně. Využijeme k tomu zabudované Nette proměnné `$basePath`. Provedeme následující zápis v základní šabloně, který netřeba komentovat.\n\n`app/templates/@layout.latte`\n/--html\n<head>\n...\n<link href=\"{$basePath}/css/screen.css\" rel=\"stylesheet\" type=\"text/css\" />\n...\n</head>\n\\--\n\nDokončení webu\n===\nTímto je web téměř hotový... na závěr ještě zvýrazníme položku menu pro stránku, na které se právě nacházíme:\n\n/--html\n<li {ifCurrent $link}class=\"current\"{/ifCurrent}>\n	<a n:href=\"$link\">{$item}</a>\n</li>\n\\--\n\n.[tip]\nPro vytvoření stránek *Produkty* a *Kontakty* je třeba vytvořit ve složce `app` příslušné presentery `ProductsPresenter`, `ContactsPresenter`, obdobně jako tomu bylo u `HomepagePresenter` a ve složce templates vytvořit odpovídající adresáře `Products` a `Contacts`. Obsahem těchto složek bude šablona presenteru s názvem `default.latte`. Její obsah musí obsahovat bloky `title` a `content`, stejně jako u šablony pro `HomepagePresenter`.\n',	'cs',	0,	'public'),
  (86,	0,	'2015-04-24 20:16:00',	'2015-04-24 20:16:00',	1721,	'Návštěvní kniha využívající AJAX',	'navstevni-kniha-vyuzivajici-ajax',	'\n.[perex]\nNásledující tutoriál Vás provede tvorbou jednoduché a nenáročné návštěvní knihy\na zasvětí Vás při tom do světa AJAXu v Nette s pomocí jQuery.\n\nPožadavky\n=========\n\n- základní znalosti Nette a dibi\n- prostředí vhodné k [vývoji a běhu aplikací v Nette | doc:requirements]\n- zhruba 30 - 60 minut času\n\n\nPříprava\n========\n\nNaší návštěvní knihu nebudeme psát úplně od základů, pomůžeme si kostrou aplikace,\nkterá je dostupná v distribučním balíku s Nette. Nachází se ve složce `tools/Skeleton`\na obsahuje předpřipravenou adresářovou strukturu, několik základních tříd a dalších souborů,\nkteré nám usnadní práci.\n\n.[note]\nPříprava skeletonu je zde popsána jen stručně a pro úplnost, větší popis\nje obsahem jiných tutoriálů.\n\nZačneme vytvořením složky v adresáři přístupném z testovacího webového serveru\na rozbalíme do ní obsah skeletonu. Do složky `libs` nakopírujeme Nette a dibi. Dále do složky `document_root/js`\nnakopírujeme [jQuery |http://docs.jquery.com/Downloading_jQuery#Current_Release].\nA abychom si tu obsluhu AJAXu v jQuery nemuseli psát sami, využijeme\njiž připravených skriptů: [jquery.nette.js | addons:cs/jquery-ajax]\na [jquery.ajaxform.js | addons:cs/ajax-form] - s nimi do stejné složky, jako s jQuery.\n\nTaké bude dobré si ihned JavaScriptové knihovny do stránky nalinkovat, ať na to\npozději nezapomeneme. Do hlavičky v souboru `app/templates/@layout.phtml` přidáme:\n\n/---html\n<script type=\"text/javascript\" src=\"{$basePath}/js/jquery.js\"></script>\n<script type=\"text/javascript\" src=\"{$basePath}/js/jquery.nette.js\"></script>\n<script type=\"text/javascript\" src=\"{$basePath}/js/jquery.ajaxform.js\"></script>\n\\---\n\nAby naše návštěvní kniha vypadala alespoň trošku k světu, stáhneme si mírně upravený\nsoubor [screen.css|http://jan.smitka.org/ajax-guestbook/files/screen.css] a\numístíme jej do složky `document_root/css`.\n\nProtože budeme psát návštěvní knihu, bude také moudré si připravit nějakou tu\ndatabázi. Použijeme SQLite, které je dostupné téměř vždy a všude. Databáze to bude\nopravdu jednoduchá - vystačíme si s jedinou tabulkou `entries`:\n\n/---code sql\nCREATE TABLE [entries] (\n	[id] INTEGER  NOT NULL PRIMARY KEY,\n	[author] VARCHAR(50)  NOT NULL,\n	[posted] TIMESTAMP  NOT NULL,\n	[ip] VARCHAR(15)  NOT NULL,\n	[text] TEXT  NULL\n);\n\nCREATE INDEX [IDX_ENTRIES_POSTED] ON [entries] (\n	[posted]  ASC\n);\n\\---\n\nCelou databázi si můžete stáhnout: [database.sdb|http://jan.smitka.org/ajax-guestbook/files/database.sdb]. Umístěte do složky `app/models`.\n\n.[note]\nPoskytnutá databáze je ve formátu SQLite 2. Můžete si stáhnout i databázi ve [formátu SQLite 3|http://jan.smitka.org/ajax-guestbook/files/database.db]. Poté ale nesmíte zapomenout použít v dibi\ndriver `sqlite3`. Pokud preferujete MySQL, je k dispozici i [export pro MySQL|http://jan.smitka.org/ajax-guestbook/files/database.sql].\n\n.[note]\nNezapomeňte, že pokud chcete, aby kniha návštěv fungovala, musí mít webserver oprávnění zapisovat nejen do souboru s databází, ale i do složky, ve které je tato databáze umístěna - v našem případě složka `app/models`. Pokud pracujete na systému, který vychází z unixu, zvažte použití příkazu `chmod -R a+rwX app/models`.\n\n\nZačínáme\n========\n\nNyní se již od kopírování a rozbalování knihoven můžeme pustit do samotné tvorby.\nAbychom demonstrovali jednoduchost a sílu AJAXu v Nette, vytvoříme nejdříve aplikaci\nbez jeho použití a až poté přidáme AJAX - se zachováním stejné funkčnosti.\n\nZačneme tedy vytvořením jednoduchého modelu a připojením k databázi.\n\n\nModely a databáze\n=================\n\nAčkoliv v tomto tutoriálu budeme pracovat jen s jedinou tabulkou a tím pádem\nsi vystačíme s jediným modelem (a tedy jedinou třídou), vytvoříme si modely dva:\nabstraktní `BaseModel`, který poslouží jako šablona pro další modely (co když bude\npotřeba zítra do aplikace přidat další funkce?), a `EntriesModel`, který bude\nreprezentovat samotnou tabulku `entries` v databázi.\n\nModely\n------\n\nJak již bylo řečeno, `BaseModel` poslouží jako kostra pro další modely.\nBude obsahovat nejen několik základních funkcí pro práci s danou tabulkou,\nale také se nám postará o připojování k databáze a odpojování od ní. Vytvoříme\nsi následující soubor `app/models/BaseModel.php`:\n\n/---php\n<?php\n\nabstract class BaseModel extends Object\n{\n	/********************* Connection handling *********************/\n\n	/** @var DibiConnection */\n	public static $defaultConnection;\n\n	/**\n	 * Establishes the database connection.\n	 */\n	public static function connect()\n	{\n		// use configuration from config.ini\n		self::$defaultConnection = dibi::connect(Environment::getConfig(\'database\'));\n	}\n\n	/**\n	 * Disconnects from the database.\n	 */\n	public static function disconnect()\n	{\n		self::$defaultConnection->disconnect();\n	}\n\n\n	/********************* Model behaviour *********************/\n\n	/** @var DibiConnection */\n	protected $connection;\n\n	/** @var string object name */\n	protected $name;\n\n	/** @var string primary key name */\n	protected $primary;\n\n	/** @var bool autoincrement? */\n	protected $autoIncrement = TRUE;\n\n\n	public function __construct(DibiConnection $connection = NULL)\n	{\n		$this->connection = ($connection !== NULL ? $connection : self::$defaultConnection);\n	}\n\n\n	/**\n	 * Selects rows from the table in specified order\n	 * @param array $order\n	 * @return DibiResult\n	 */\n	public function fetchAll(array $order = array())\n	{\n		return $this->connection->query(\n			\'SELECT * FROM %n\', $this->name,\n			\'%ex\', (!empty($order) ? array(\'ORDER BY %by\', $order) : NULL)\n		);\n	}\n\n\n	/**\n	 * Inserts a new row\n	 * @param array $values to insert\n	 * @return\n	 */\n	public function insert(array $values)\n	{\n		return $this->connection->insert($this->name, $values)\n			->execute($this->autoIncrement ? dibi::IDENTIFIER : NULL);\n	}\n}\n\\---\n\nCelá třída obsahuje jen ty funkce, které budeme pro náš příklad potřebovat.\nJistě by se našlo místo na další funkce (aktualizace záznamů, složitější vybírání\nz databáze, ...), ne však v tomto tutoriálu.\n\nTřída se může na první pohled zdát složitá, po bližším prozkoumání však o nic\nsložitého nejde. Navíc oč složitější je tato třída, o to jednodušší budou další\nmodely. `app/models/EntriesModel.php` bude vypadat takto:\n\n/---php\n<?php\n\nclass EntriesModel extends BaseModel\n{\n	protected $name = \'entries\';\n}\n\\---\n\nObsahuje jen definici názvu tabulky. Nic dalšího potřeba skutečně není.\n\nPřipojení k databázi\n--------------------\n\n.[note]\nTento tutoriál je psán pro Nette 0.9. V současné verzi Nette 2.0 se konfigurace provádí trochu jinak, viz \"Konfigurace Nette Frameworku\":[http://doc.nette.org/cs/configuring/nette-framework].\n\nMetoda `BaseModel::connect()` nám sice umožňuje připojit se k databázi,\nmusíme jí ale někde zavolat a také musíme do `config.ini` zapsat údaje\npro připojení.\n\nZačneme tedy těmi údaji. Do souboru `app/config.ini` přidáme před začátek sekce\n`[production < common]` následující řádky:\n\n/---code ini\n[common.database]\ndriver = sqlite\ndatabase = %appDir%/models/database.sdb\n\\---\n\n.[note]\nPokud chcete použít databázi ve formátu SQLite 3, použijte driver `sqlite3`.\nFormáty nejsou zaměnitelné, takže nelze načíst SQLite 2 databázi pomocí\ndriveru `sqlite3` a naopak. Pokud zatím s dibi moc nekamarádíte, můžete\nse také podívat na [příklad konfigurace pro MySQL|http://jan.smitka.org/ajax-guestbook/files/config.mysql.ini].\n\nTo nám vytvoří podsekci konfigurace s názvem `database` platnou pro všechna prostředí.\n\n.[note]\nKdyž už máte otevřený soubor `config.ini`, povšimněte si\n[bezpečnostního varování | www:security-warning].\n\nNyní už zbývá se k databázi připojit. Toho dosáhneme pomocí událostí aplikace.\nDo souboru `app/bootstrap.php` přidáme před volání `$application->run();` následující\nřádky kódu:\n\n/---php\n$application->onStartup[] = \'BaseModel::connect\';\n$application->onShutdown[] = \'BaseModel::disconnect\';\n\\---\n\nTím aplikaci nadefinujeme, že se má během svého spouštění připojit k databázi\nvoláním metody `BaseModel::connect()` a při ukončování se zase slušně odpojit\nvoláním `BaseModel::disconnect()`.\n\nA to je k databázi vše. Pokud nyní při otevření aplikace v prohlížeči nespatříte\nchybové hlášení, aplikace je připravena pracovat s databází.\n\n\nVýpis příspěvků a jejich přidávání\n==================================\n\nNávštěvní kniha většinou obsahuje jen jednu jedinou stránku - pro výpis a současně\ni přidávání příspěvků. To nám situaci zjednodušuje a můžeme pracovat na poli\njediného presenteru - `HomepagePresenter`u. V našem případě by měl obsahovat\nněkolik základních částí:\n\n- získání seznamu příspěvků z databáze\n- vykreslení seznamu v šabloně\n- definice formuláře a zpracování jeho dat\n- vykreslení formuláře v šabloně\n\nZačneme seznamem...\n\nSeznam příspěvků\n----------------\n\nAbychom se dostali k seznamu příspěvků, musíme použít model. Máme několik možností,\njak model vytvářet:\n\n1. vytvořit si jednu instanci modelu v metodě `startup` presetneru a tu používat\n2. vytvořit si novou instanci modelu při každém použití v presenteru\n3. vytvořit si chytře jedinou instanci modelu při prvním použití a tu pak používat i později\n\nPoslední způsob je asi nejelegantnější, použijeme proto ten. Jmenuje se lazy loading.\nVytvoříme si jednoduchou funkci (getter), která bude kontrolovat, zda je daná členská\nproměnná `NULL`. Pokud ano, tak vytvoří novou instanci modelu. Na konci tuto\nproměnnou vrátí. Třída `HomepagePresenter` v souboru `app/presenters/HomepagePresenter.php`\nbude vypadat takto:\n\n/---php\n<?php\n\nclass HomepagePresenter extends BasePresenter\n{\n	/** @var EntriesModel */\n	protected $entriesModel;\n\n	/**\n	 * Lazy getter for EntriesModel\n	 * @return EntriesModel\n	 */\n	public function getEntries()\n	{\n		if ($this->entriesModel === NULL)\n			$this->entriesModel = new EntriesModel();\n		return $this->entriesModel;\n	}\n}\n\\---\n\nV presenteru pak budeme používat členskou proměnnou `$entries` - díky\n[taťkovi všech objektů | doc:nette-object] se bude volat náš getter `getEntries()`.\n\nZde to může působit trochu jako kanón na mouchy, ale je dobré si na podobné\nkonstrukce zvyknout - líné vytváření objektů je velmi výhodné u větších aplikací.\nPokud budeme mít modelů více a budeme s nimi muset pracovat z více tříd,\npak budeme muset najít nějaké lepší a pohodlnější řešení. Pro jeden model však\nzůstaneme u této relativně jednoduché metody.\n\nBudeme pokračovat metodou `renderDefault()`, která data z databáze načte\na připraví je šabloně:\n\n.[tip]\nPokud si nejste jistí, proč zrovna `renderDefault()`, konzultujte dokumentaci či\njiný tutoriál.\n\n/---php\nclass HomepagePresenter extends BasePresenter\n{\n	/* .... */\n\n	/********************* Default view *********************/\n\n	public function renderDefault()\n	{\n		$this->template->entries = $this->entries->fetchAll(array(\'posted\' => dibi::DESC));\n	}\n}\n\\---\n\nA nakonec samotná šablona. Soubor `app/templates/Homepage/default.phtml`\nupravíme takto:\n\n/---html\n{block content}\n\n<h1>Kniha návštěv</h1>\n\n<div class=\"list\">\n{if count($entries) > 0}\n	{foreach $entries as $entry}\n	<div class=\"entry\">\n		<div class=\"author\">{$entry->author}</div>\n		<div class=\"text\">{!$entry->text|escape|nl2br}</div>\n		<div class=\"posted\">{$entry->posted}</div>\n	</div>\n	{/foreach}\n{else}\n	<div class=\"notice\">Kniha návštěv zatím neobsahuje žádné příspěvky.</div>\n{/if}\n</div>\n\\---\n\nPokud jsme nikde neudělali chybu, bude výstup nyní následující:\n\n[* screen-1.png *]\n\nSeznam je prázdný, ale aby ho mohl někdo naplnit, musí mít jak.\n\nFormulář pro přidávání příspěvků\n--------------------------------\n\nAbychom mohli nějaký formulář v šabloně vykreslit, musíme jej nejdříve nadefinovat.\nTo uděláme opět ve třídě `HomepagePresenter`, vytvoříme si na formulář\n[továrničku | doc:nette-application-presenter#toc-tovarnicky-na-komponenty]. Ta\nnám formulář vytvoří až v momentě, kdy je ho skutečně potřeba. U presenterů\ns mnoha komponentami a mnoha pohledy by bylo nákladné vytvářet\nvždy všechny komponenty a pracné je ručně vytvářet před prvním použitím,\nproto nám práci usnadní zmíněná továrnička:\n\n/---php\n	protected function createComponentPostForm()\n	{\n		$form = new AppForm();\n		$form->addText(\'author\', \'Jméno:\', 30, 50)\n			->addRule(Form::FILLED, \'Jméno je povinné.\');\n		$form->addTextArea(\'text\', \'Text:\', 50, 8)\n			->addRule(Form::FILLED, \'Text příspěvku je povinný.\');\n		$form->addSubmit(\'save\', \'Přidat příspěvek\');\n		$form->onSubmit[] = array($this, \'postForm_onSubmit\');\n		return $form;\n	}\n\\---\n\nTato továrnička bude vytvářet formulář s názvem `postForm`. Tento název pro nás bude\ndůležitý hlavně při vykreslování formuláře v šabloně.\nFormulář má 2 políčka, jedno na jméno a druhé na text. Obě jsou povinná, nechceme\npřeci anonymní příspěvky bez textu. Pod políčky je tlačítko na odeslání,\no odeslání se bude starat metoda `postForm_onSubmit()` v aktuálním třídě (tedy\nve třídě `HomepagePresenter`). Aby formulář po odeslání příspěvek skutečně přidal,\nmusíme si onu metodu nadefinovat:\n\n/---php\n	public function postForm_onSubmit(Form $form)\n	{\n		$entry = $form->getValues();\n		$entry[\'posted\'] = new DateTime();\n		$entry[\'ip\'] = Environment::getHttpRequest()->remoteAddress;\n		$this->entries->insert($entry);\n\n		$this->flashMessage(\'Váš příspěvek byl uložen. Děkujeme za Váš čas.\');\n		$this->redirect(\'this\');\n	}\n\\---\n\nVykreslení samotného formuláře na stránce provedeme v šabloně pomocí makra `{control}`, kterému jako parametr udáme název komponenty, v našem případě `postForm`. Toto makro si od presenteru vyžádá danou komponentu a ten, pokud již komponenta neexistuje, zavolá naší továrničku a komponentu vytvoří.\n\n.[note]\nV názvu komponenty je rozlišována velikost písmen a při použití továrniček začíná název\nkomponenty vždy malým písmenem. Pokud dostáváte od aplikace chybu o neexistující komponentě,\nzkontrolujte právě velikost písmen.\n\n.[note]\nV některých příkladech můžete narazit i na použití makra `{widget}`. Pokud Vás zajímá, jaký je mezi\ntěmito dvěma makry rozdíl, tak vězte, že žádný. `{control}` je jen z historického hlediska aliasem\npro `{widget}`.\n\n/---html\n{block content}\n\n<h1>Kniha návštěv</h1>\n\n{control postForm}\n\n<div class=\"list\">\n{* ... *}\n</div>\n\\---\n\nNyní už by měla kniha fungovat a hosté mohou psát:\n\n[* screen-2.png *]\n\nTeď už si jistě říkáte: kde je ten slibovaný AJAX? Nebude teď dost práce tam\npřidat AJAXová volání, AJAXové zpracování... ? Nebude.\n\nAJAX\n====\n\nJeště než se pustíme do přidělání AJAXu do samotné aplikace, musíme se postarat\no správné přepsání událostí v JavaScriptu, aby vůbec došlo k jeho volání.\nZa tímto účelem si vytvoříme malý script ve složce `document_root/js`. Nazveme\njej třeba `ajax.js`. Jeho obsah bude zhruba následující:\n\n/---js\n/* Volání AJAXu u všech odkazů s třídou ajax */\n$(\"a.ajax\").live(\"click\", function (event) {\n	event.preventDefault();\n	$.get(this.href);\n});\n\n/* AJAXové odeslání formulářů */\n$(\"form.ajax\").live(\"submit\", function () {\n	$(this).ajaxSubmit();\n	return false;\n});\n\n$(\"form.ajax :submit\").live(\"click\", function () {\n	$(this).ajaxSubmit();\n	return false;\n});\n\\---\n\nPrvní část scriptu přidá všem odkazům s třídou `ajax` událost,\nkterá po kliknutí na ně vykoná AJAXový požadavek a zruší přechod\nna další stránku. Druhá část, která se týká formulářů, má obdobný efekt:\npo odeslání formuláře se data odešlou pomocí AJAXu a odeslání\nnormální cestou se přeruší. Použití funkce `live` zajišťuje,\nže se událost přidá jak všem současným prvkům, tak i těm, které\ndo stránky budou přidány - například AJAXem.\n\n.[note]\nVolání funkce `live` pro událost `submit` je možné až od jQuery verze\n1.4. Pro nižší verze použijte plugin [Live Query | http://plugins.jquery.com/project/livequery].\n\nOpět nalinkujeme do stránky v `@layout.phtml`. A nyní již hurá na přidání AJAXu!\n\nSnippety\n--------\n\n.[note]\nTento tutoriál je psán pro Nette 0.9. V současné verzi Nette 2.0 už se zavináče nepíší, viz \"Historie ajaxu v Nette\":[http://forum.nette.org/cs/5831-snippety-ajax-zapis-historie#p43519], jinak se ale snippety používají velmi podobně.\n\nNejjednodušším způsobem, jak překreslit část stránky v Nette, je uzavřít ji do\nsnippetu a ten překreslovat. V našem případě budeme mít snippety tři - formulář,\nkterý budeme chtít po úspěšném odeslání vyprázdnit, seznam příspěvků a flash\nzprávičky v `@layout.phtml`. Současná stabilní verze také vyžaduje použití\n\"zavináčové magie\":[http://forum.nette.org/cs/2451-zavinacova-magie-v-praxi],\ntakže musíme přidat zavináč před úvodní makro `{block content}`.\nŠablonu `default.phtml` tedy upravíme takto:\n\n/---html\n@{block content}\n\n<h1>Kniha návštěv</h1>\n\n{snippet form}\n{control postForm}\n{/snippet}\n\n{snippet list}\n<div class=\"list\">\n{if count($entries) > 0}\n	{foreach $entries as $entry}\n	<div class=\"entry\">\n		<div class=\"author\">{$entry->author}</div>\n		<div class=\"text\">{!$entry->text|escape|nl2br}</div>\n		<div class=\"posted\">{$entry->posted|date}</div>\n	</div>\n	{/foreach}\n{else}\n	<div class=\"notice\">Kniha návštěv zatím neobsahuje žádné příspěvky.</div>\n{/if}\n</div>\n{/snippet}\n\\---\n\nPoslední snippet přijde do šablony `@layout.phtml` a bude obalovat vykreslování\nflash zpráviček - i uživatelům s AJAXem je jistě budeme chtít zobrazit. Také nesmíme\nzapomenout na zavináč před makro `{include #content}`, jinak by při AJAXových\npožadavcích nedocházelo k vkládání (a tím pádem ani k vykonání) bloku a snippety by nefungovaly.\n\n/---html\n<body>\n	{snippet flashes}\n	{foreach $flashes as $flash}<div class=\"flash {$flash->type}\">{$flash->message}</div>{/foreach}\n	{/snippet}\n\n	@{include #content}\n</body>\n\\---\n\n\nZměny v presenteru\n------------------\n\nZměn v samotném presenteru nebude mnoho. Formuláři jen přiřadíme třídu AJAX a\nmírně poupravíme zpracování formuláře:\n\n/---php\n	protected function createComponentPostForm()\n	{\n		$form = new AppForm();\n		$form->getElementPrototype()->class(\'ajax\');\n		// ...\n	}\n\\---\n\n/---php\n	public function postForm_onSubmit(Form $form)\n	{\n		$entry = $form->getValues();\n		$entry[\'posted\'] = new DateTime();\n		$entry[\'ip\'] = Environment::getHttpRequest()->remoteAddress;\n		$this->entries->insert($entry);\n\n		$this->flashMessage(\'Váš příspěvek byl uložen. Děkujeme za Váš čas.\');\n		if (!$this->isAjax())\n			$this->redirect(\'this\');\n		else {\n			$this->invalidateControl(\'list\');\n			$this->invalidateControl(\'form\');\n			$form->setValues(array(), TRUE);\n		}\n	}\n\\---\n\nNa konec jsme jen přidali podmínku - v případě AJAXového požadavku neprovádíme\npřesměrování, ale zneplatníme dva snippety a voláním `$form->setValues(array(), TRUE);`\nvyprázdníme formulář.\n\nJediný snippet, který jsme nezneplatnili, byl ten kolem flash zpráviček. Drobnou\nfunkcí umístěnou do třídy `BasePresenter` se však o jejich zneplatnění nemusíme\nvůbec starat a vše může probíhat automaticky. Do třídy `BasePresenter` v souboru\n`app/presenters/BasePresenter.php` tedy můžeme umístit následující funkci:\n\n/---php\n	public function afterRender()\n	{\n		if ($this->isAjax() && $this->hasFlashSession())\n			$this->invalidateControl(\'flashes\');\n	}\n\\---\n\nTa zajistí, že v případě nastavených flash zpráviček se u AJAXového požadavku\nsnippet automaticky invaliduje a my se o to vůbec nemusíme starat.\n\nA to je vše. Nyní už by se měl formulář odeslat AJAXem a seznam příspěvků\nby se měl automaticky aktualizovat.\n\n\nStránkování\n===========\n\nMáme již sice před sebou plně funkční knihu návštěv, která navíc používá\nAJAX, něco tomu ale stále chybí - stránkování. Po čase by se naše kniha\nnávštěv značně zaplnila a znepřehlednila samými pozitivními komentáři,\ntakže je moudré je rozdělit do stránek.\n\nK tomu si vypůjčíme již hotovou komponentu [VisualPaginator | addons:cs/visualpaginator].\nNette již sice obsahuje třídu [Paginator | api:], ta ale obsahuje jen základní\nlogiku potřebnou ke stránkování a neumí vykreslit žádný pro uživatele přívětivý\nvýstup. Komponenta VisualPaginator je jen jakousi obálkou, která se stará o\nvykreslování zmíněné třídy.\n\n.[tip]\nPři používání komponent třetích stran věnujte prosím pozornost její licenci.\nNěkteré licence Vám neumožňují použít danou komponentu, pokud nesplňujete\nurčité podmínky. Například komponenty s licencí [GNU GPL | http://www.gnu.org/copyleft/gpl.html]\nmůžete s projektem distribuovat jen tehdy, kdy i samotný projekt bude distribuován\npod licencí GNU GPL. Toto omezení se však týká jen distribuce projektu - pokud\nprojekt nebudete nijak šířit, můžete komponentu použít bez problémů.\nToto je vhodné si uvědomit zejména u komerčních projektů, kdy se i dodání webu\nzákazníkovi považuje za distribuci.\nVisualPaginator je šířen pod licencí New BSD, která povoluje prakticky jakékoliv\npoužití za předpokladu, že budou v komponentě ponechány copyrighty a prohlášení\no zodpovědnosti za škodu.\n\nVytvoříme si složku `app/components` a do ní rozbalíme složku `VisualPaginator`\nz distribučního archivu s komponentou. Stylopis `example.css` můžeme přesunout\ndo složky `document_root/css` a nalinkovat do stránky. Nyní máme vše připravené\na můžeme se pustit do samotné implementace stránkování.\n\nZačneme od modelu. Náš současný model umožňuje jen získání celého\nseznamu v databázi. Pokud budeme stránkovat, bude praktičtější,\nkdyž už samotný dotaz bude obsahovat klauzule `LIMIT` a `OFFSET`,\nkteré nám rozsah výsledků patřičně omezí. Můžeme si tedy upravit\nmetodu `fetchAll()` třídy `EntriesModel` tak, aby toto omezení\nzohledňovala. O něco praktičtější však bude použít třídu `DibiDataSource`,\nkterá je pro tento účel přímo stvořená.\n\nDo třídy `BaseModel` tedy přidáme novou metodu: `getDataSource`,\nkterá vrátí novou instanci `DibiDataSource`:\n\n/---php\n	/**\n	 * Creates a new DataSource\n	 * @return DibiDataSource\n	 */\n	public function getDataSource()\n	{\n		return new DibiDataSource($this->name, $this->connection);\n	}\n\\---\n\nTřídě `DibiDataSource` se jako první argument konstruktoru zadává zdroj,\nze kterého se mají data vybírat. To může být buď název tabulky, jako\nv našem případě, nebo SQL dotaz. V případě použití SQL dotazu se\npoužije jako poddotaz.\n\n.[note]\nPoužití SQL dotazu se nedoporučuje v případě MySQL databáze.\nTa totiž neumí použít indexy v tabulkách z poddotazu, takže\nje poté `DibiDataSource` silně neefektivní.\n\nNyní se přesuneme do třídy `HomepagePresenter`, která bude\nhlavním dějištěm našeho stránkování. Nejdříve upravíme metodu\n`renderDefault()` tak, aby prozatím používala novou metodu modelu,\nale zatím nestránkovala:\n\n/---php\n	public function renderDefault()\n	{\n		$dataSource = $this->entries->getDataSource();\n		$dataSource->orderBy(\'posted\', dibi::DESC);\n		$this->template->entries = $dataSource;\n	}\n\\---\n\nVoláním metody `orderBy()` nad objektem `$dataSource` nastavujeme totéž,\nco jsme dřív předávali jako parametr metodě `fetchAll` - sestupné řazení\npodle sloupce `posted`.\n\nPoužití `DibiDataSource` v šabloně bude stejné, jako by šlo již o hotový\nvýsledek. Při pokusu procházet přes jeho prvky se totiž automaticky vykoná\nvýsledný dotaz a pro procházení se použije jeho výsledek. To nám umožňuje\nlibovolně upravovat parametry `DibiDataSource` až do jeho použití při vykreslování.\n\nNyní se pustíme do samotného stránkování. Vytvoříme si továrničku na komponentu\nVisualPaginator:\n\n/---php\n	protected function createComponentPaginator()\n	{\n		$visualPaginator = new VisualPaginator();\n		$visualPaginator->paginator->itemsPerPage = 10;\n		return $visualPaginator;\n	}\n\\---\n\nPovšimněte si řádku `$visualPaginator->paginator->itemsPerPage = 10;`. Jak již\nbylo dříve zmíněno, slouží třída `VisualPaginator` jako obálka nad třídou\n`Paginator`. Právě ta řídí veškerou stránkovací logiku a parametry\nstránkování musíme přiřazovat právě jí. Tu třída `VisualPaginator`\nobsahuje v [property | doc:nette-object#toc-gettery-a-settery] `paginator`.\nZmíněný řádek tedy třídě `Paginator` říká, že si přejeme na stránce zobrazit\n10 záznamů.\n\nDále musíme zohlednit stránkování při sestavování `DibiDataSource`.\nJe potřeba předat třídě `Paginator` informace o celkovém počtu objektů\nv databázi a objektu `DibiDataSource` naopak nastavit pomocí metody\n`applyLimit()` limit a offset. Oba parametry získáme ze třídy `Paginator`.\nCelá metoda `renderDefault()` bude nyní vypadat takto:\n\n/---php\n	public function renderDefault()\n	{\n		$dataSource = $this->entries->getDataSource();\n		$dataSource->orderBy(\'posted\', dibi::DESC);\n\n		$paginator = $this[\'paginator\']->getPaginator();\n		$paginator->itemCount = $dataSource->getTotalCount();\n		$dataSource->applyLimit($paginator->itemsPerPage, $paginator->offset);\n\n		$this->template->entries = $dataSource;\n	}\n\\---\n\nNyní už nám zbývá jen naší novou komponentu ve stránce vykreslit. Opět použijeme\nmakro `{control}` a umístíme jí do snippetu `list`:\n\n/---html\n{snippet list}\n<div class=\"list\">\n{if count($entries) > 0}\n	{control paginator}\n\n	{foreach $entries as $entry}\n	<div class=\"entry\">\n		<div class=\"author\">{$entry->author}</div>\n		<div class=\"text\">{!$entry->text|escape|nl2br}</div>\n		<div class=\"posted\">{$entry->posted|date}</div>\n	</div>\n	{/foreach}\n\n	{control paginator}\n{else}\n	<div class=\"notice\">Kniha návštěv zatím neobsahuje žádné příspěvky.</div>\n{/if}\n</div>\n{/snippet}\n\\---\n\nNyní se už stránkování nejen zobrazí, ale také je plně funkční.\n\n[* screen-3.png *]\n\nAle pozor! Při změně stránky se nepoužívá AJAX. Po kliknutí na odkaz vůbec\nnedojde k AJAXovému volání, navíc by zatím ani nedošlo k překreslení žádného\nsnippetu. Pojďme to tedy napravit...\n\nPro přidání AJAXového volání po kliknutí na odkaz v máme 2 možnosti:\n\n- přidáme odkazům v šabloně paginatoru třídu `ajax`\n- upravíme `ajax.js` tak, aby AJAXová volání přiřadil automaticky i odkazům stránkovače\n\nZvolíme druhé řešení, protože je méně pracné - stačí jen přidat selektor `.paginator a`\ndo `ajax.js`:\n\n/---js\n$(\"a.ajax, .paginator a\").live(\"click\", function (event) {\n	event.preventDefault();\n	$.get(this.href);\n});\n\\---\n\nPřekreslení snippetu je jednoduché, nicméně mírně neelegantní - komponenta\nVisualPaginator neobsahuje žádný mechanismus, kterým by bylo možné zajistit\nvyvolání vlastního kódu v případě změny stránky. V podstatě ani není možné takový\nmechanismus elegantně zajistit - komponenta neví, jakou stránku měl uživatel,\nod kterého AJAXový požadavek přišel, právě zobrazenou. Vše by se muselo řešit\npřes dodatečný parametr.\n\nDovolíme si tedy použít jednodušší řešení - snippet se seznamem příspěvků nebudeme\nzneplatňovat pouze v případě, že uživatel odeslal formulář, ale při každém požadavku.\n\nVolání `invalidate()` se nám tedy přesune do metody `renderDefault()`:\n\n/---php\n	public function renderDefault()\n	{\n		// ...\n\n		$this->template->entries = $dataSource;\n		if ($this->isAjax())\n			$this->invalidateControl(\'list\');\n	}\n\\---\n\nTaké by bylo vhodné uživateli po odeslání formuláře zobrazit první stránku s jeho příspěvkem.\nPřidáme tedy do metody `postForm_onSubmit` následující řádek:\n\n/---php\n		$this[\'paginator\']->page = $this[\'paginator\']->paginator->page = 1;\n\\---\n\nŘádek obsahuje dvě přiřazení - bohužel je nutné současnou stránku zvlášť nastavit\nkomponentě VisualPaginator a zvlášť třídě `Paginator`, kterou komponenta obsahuje.\n\nV tento okamžik by i stránkování mělo fungovat AJAXově a naše návštěvní\nkniha je zase o kousek lepší.\n\n\nZávěr\n=====\n\nSestavili jsme jednoduchou knihu návštěv v Nette, která používá AJAX.\nTrochu paradoxně jsme naprostou většinu času strávili psaním základního\nkódu, který s AJAXem nesouvisel, a změny při přidávání AJAXu nad celou\naplikaci byly minimální.\n\nNabízí se další rozšíření návštěvní knihy - ochrana proti spamu,\nmoderování příspěvků... Některá rozšíření mohou postupně přibýt\ndo tohoto tutoriálu, záleží na Vašem zájmu.\n\nCelou aplikaci si můžete [vyzkoušet | http://jan.smitka.org/ajax-guestbook/demo/]\ni [stáhnout | http://jan.smitka.org/ajax-guestbook/files/ajax-guestbook.zip].\n',	'cs',	0,	'public'),
  (87,	0,	'2015-04-24 20:17:01',	'2015-04-24 20:17:01',	1721,	'Vlastní validační pravidla',	'vlastni-validacni-pravidla',	'\n.[perex]\nObčas se dostaneme do situace, kdy nám vestavěná validační pravidla v Nette nestačí a potřebujeme data od uživatele validovat po svém. V Nette je to velmi jednoduché!\n\nValidační pravidla přidáváme k jednotlivým komponentám formuláře pomocí metody [addRule|api:Nette\\Forms\\Controls\\BaseControl::addRule()]. Prvním parametrem této metody je typ pravidla - `$operation`. Běžně jako pravidla používáme konstanty ze třídy [Form|api:Nette\\Forms\\Form::constants].\n\nJejich hodnoty začínají znakem `:`. Jedná se o speciální tvar, který formuláři říká, jaká metoda formulářové komponenty se má pro validaci použít. Název za dvojtečkou se doplní prefixem `validate` při validaci se volá jako statická metoda nad třídou formulářového prvku.\n\nPokud tedy přidáme na [TextInput|api:Nette\\Forms\\Controls\\TextInput] pravidlo zadané konstantou `Form::FILLED`, která má hodnotu `:filled`, bude se při validaci volat statická metoda `Nette\\Forms\\Controls\\TextInput::validateFilled()` (kterou třída dědí od [BaseControl|api:Nette\\Forms\\Controls\\BaseControl]).\n\nValidační pravidlo by mělo přijímat jako první parametr instanci validované komponenty a vracet boolean hodnotu `TRUE`/`FALSE`. Při přidávání pravidla je možné zadat i další argumenty, ty jsou pak předány jako druhý parametr.\n\nPokud tedy chceme přidat vlastní pravidlo, které bude voláno touto cestou, musíme přidat třídě statickou metodu. To je však možné pouze u námi vytvořených komponent.\n\nProtože vytvářet vlastní komponentu pouze kvůli vlastnímu validačnímu pravidlu není moc pohodlné, můžeme si pomoci jinak. Jako parametr `$operation` můžeme použít jakýkoliv callback, a to zadaný buď jako řetězec (= statická metoda), nebo pomocí pomocné metody [callback()|api:function-callback].\n\nPokud předáme callback jako řetězec, umožní to navíc i validaci na klientské straně. Skript \"netteForms.js\":[https://github.com/nette/nette/blob/master/client-side/forms/netteForms.js] v takovém případě z calbacku odstraní `\\` (oddělovač namespace), slavný \"paamayim nekudotayim\" - `::` - nahradí za podtržítko, a podívá se, zda je validátor s takovým názvem zaregistrovaný v `Nette.validators`.\n\nNapříklad pro callback `MyApp\\Forms\\Rules::validateNumber` se hledá `Nette.validators.MyAppFormsRules_validateNumber`. Pro vlastní zpracování pak stačí v klientském JavaScriptu tuto členskou proměnnou nastavit na callback.\n\nVytvoření vlastní sady validátorů se tak stává naprosto triviální záležitostí. Stačí vytvořit třídu se statickými metodami a příslušnými konstantami:\n\n/---php\nclass UserFormRules\n{\n	const USERNAME = \'UserFormRules::validateUsername\';\n	const EMAIL_DOMAIN = \'UserFormRules::validateEmailDomain\';\n\n	public static function validateUsername(IControl $control)\n	{\n		// validace uživatelského jména\n	}\n\n	public static function validateEmailDomain(IControl $control, $domain)\n	{\n		// validace, zda se jedné o e-mail z domény $domain\n	}\n}\n\\---\n\nPoužití je pak velmi jednoduché:\n\n/---php\n$form->addText(\'username\', /* label, velikost... */)\n	->addRule(UserFormRules::USERNAME, /* validační zpráva */);\n$form->addText(\'email\', /* label, velikost... */)\n	->addRule(UserFormRules::DOMAIN, /* validační zpráva */, \'example.com\');\n\\---\n\nVe validačních metodách je vhodné zkontrolovat, zda je formulářový prvek vhodného typu (např. `$control instanceof TextBase`). Při tomto použití validačních pravidel nám totiž nic nebrání naše pravidla přidat například k souborovému inputu.\n\nMůžeme také přidat validaci na klientovi:\n\n/---js\nNette.validators.UserFormRules_validateUsername = function (elem, arg, value) {\n	// validace uživatelského jména (value)\n};\n\nNette.validators.UserFormRules_validateEmailDomain = function (elem, domain, value) {\n	// validace, zda value je e-mail z domény arg\n};\n\\---\n',	'cs',	0,	'public'),
  (88,	0,	'2015-04-24 20:19:59',	'2015-04-24 20:19:59',	1860,	'Nette & Doctrine',	'nette-doctrine',	'.[perex]\nV tomto tutoriáli sa naučíte sprevádzkovať spoluprácu Nette s ORM Doctrine. Doctrine bude následne vo vašej aplikácii vystupovať ako Model.\n\n\nPredhovor\n===\nDoctrine je pokročilý ORM framework, ktorý posúva možnosti a pohodlie práce s Modelom o veľký kus dopredu. V tomto tutoriáli sa naučíte \"dosadiť\" Doctrine do pozície Modelu, vyskúšate si prácu s konzolovým rozhraním **doctrine-cli** a sprevádzkujete napojenie Doctrine na vstavaný profiler.\n\n.[note]\nAby konzolové rozhranie správne pracovalo aj v prostredí Windows, je potrebné správne nakonfigurovať niekoľko tzv. \"environment premenných\" prostredia Windows. V tomto tutoriáli nájdete podrobný postup ako PHP na konzoli sprevádzkovať. Užívateľov unixových operačných systémov sa táto poznámka netýka.\n\nČo budete potrebovať?\n===\n- Stiahnite si aktuálne stabilné vydanie Nette Framework (tutoriál je určený pre verziu PHP 5.2 ale s malými úpravami samozrejme pobeží aj na PHP 5.3). Z tohto balíka budete potrebovať knižnice Nette a tzv. skeleton, ktorý nájdete v zložke **tools\\Skeleton**.\n- Zo stránok projektu Doctrine si \"stiahnite archív\":http://www.doctrine-project.org/download#1_2 verzie 1.2. Sťahujte súbor s názvom *Doctrine-1.2.x.tgz*, tzv. **sandbox nie je pre tento tutoriál vhodný**.\n- Vytvorte si pracovnú zložku pre projekt, napr. **nette-doctrine** a príp. sprevádzkujte nový VirtualHost.\n\nŠtruktúra projektu\n===\n- Do zložky projektu nakopírujte obsah **tools/Skeleton** z distribučného archívu Nette Framework. Nezabudnite nastaviť práva na zápis nad zložkami **nette-doctrine/app/log** a **nette-doctrine/app/temp**.\n- Vyprázdnite zložku **nette-doctrine/app/models**\n- Do zložky **nette-doctrine/libs** nakopírujte knižnice Nette Framework.\n- Pripravte zložku pre knižnice Doctrine - vytvorte **nette-doctrine/libs/Doctrine**.\n- Rozbaľte archív s Doctrine a vyhľadajte zložku **lib**. Z tejto zložky zoberte adresár **Doctrine** a súbor **Doctrine.php** a nakopírujte ich do zložky, ktorú ste vytvorili v predošlom kroku (nette-doctrine/libs/Doctrine).\n- Vytvorte zložku **nette-doctrine/scripts**\n- V zložke **nette-doctrine/app** vytvorte adresár **doctrine** a túto štruktúru podadresárov:\n/--\ndoctrine/\n  data/\n    fixtures/\n    sql/\n  migrations/\n  schema\n\\--\n*tieto zložky slúžia na skladovanie súborov pre konzolový program **doctrine-cli**. Jedná sa predovšetkým o konfiguračné súboory YAML a generované SQL skripty*\n\n.[note]\nFungovanie konzolového rozhrania nie je nutným požiadavkom prevádzky Doctrine v Nette Framework. Výraznou mierou však spríjemňuje prácu a vývoj aplikácií. Preto vám odporúčame, aby ste si konzolové rozhranie sprevádzkovali.\n\nTým je projekt pripravený. Výslednú štruktúru znázorňuje následujúci obrázok:\n\n[* nette-doctrine-structure2.png *]\n\nDoctrine v rámci Nette Framework\n===\nKnižnice Doctrine bude \"naťahovať\" RobotLoader, preto skontrolujte jeho konfiguráciu v **app/config.ini**. Okrem toho, do súboru zapíšte konfiguráciu databázovehého pripojenia. V tejto chvíli ju zapíšte do sekcie *common*, hneď za konfiguráciu RobotLoadera:\n\n/--\n; == database ==\ndatabase.driver = mysql\ndatabase.host = localhost\ndatabase.username = php\ndatabase.password = php\ndatabase.database = nette_doctrine\ndatabase.profiler = true\n\\--\n\nTeraz sa zamerajte na súbor **app/bootstrap.php**. Do tohto súboru sa zvyčajne ukladá kód, ktorý inicializuje databázové spojenie - databázovému enginu je predaná konfigurácia zapísaná v **app/config.ini**. Na konci súboru bootstrap je potom aplikácia spustená.\n\nKedže konzolové rozhranie nepracuje s aplikáciou, musíte sa nejakým spôsobom vyhnúť volaniu\n\n/--php\n$application->run();\n\\--\n\nNajjednoduchšie to spravíte tak, že konfigurácia DB enginu sa vykoná v inom súbore a tento v **bootstrap.php** \"nainkludujete\". Aby ste však mohli pristupovať ku **config.ini** tak ako ste zvyknutý ( pomocou *Environment::loadConfig()* ) je nutné Nette/loader.php natiahnuť už v tomto separátnom súbore. Vytvorte teda nový súbor **app/bootstrap.db.php** a na jeho začiatok vložte kód\n\n/--php\n<?php\n\nrequire LIBS_DIR . \'/Nette/loader.php\';\n\\--\n\nZároveň rovnaký riadok zmažte z **app/bootstrap.php** a na jeho miesto vložte kód\n\n/--php\nrequire(dirname(__FILE__) . \'/bootstrap.db.php\');\n\\--\n\nDo nového súboru teraz treba vložiť kód, ktorý predá Doctrine databázovú konfiguráciu. Táto musí byť vo forme pomerne nepekného, tzv. *dsn reťazca*. Je to obyčajný String, v ktorom je každá časť konfigurácie (DB driver, server, meno, heslo) oddelená nejakým separátorom. Schéma tohto stringu je približne takáto\n\n/--php\ndbDriver://dbUsername:dbPassword@server/database\n\\--\n\nNa mieste *dbDriver* je možné použiť niektorý z podporovaných driverov\n\n- fbsql (FrontBase)\n- ibase (InterBase / Firebird)\n- mssql (Microsoft SQL Server)\n- mysql (MySQL)\n- oci (Oracle 7/8/9/10)\n- pgsql (PostgreSQL)\n- querysim (QuerySim)\n- sqlite\n\nOstatné sekcie *dsn reťazca* sú samovysvetľujúce. Do **app/bootstrap.db.php** je teda potrebné vložiť kód, ktorý dsn reťazec zostaví z konfigurácie uloženej v **app/config.ini**\n\n/--php\nEnvironment::loadConfig();\n\n$dbConfig = Environment::getConfig(\'database\');\n$conn = Doctrine_Manager::connection($dbConfig->driver . \'://\' . $dbConfig->username . \':\' . $dbConfig->password . \'@\' . $dbConfig->host . \'/\' . $dbConfig->database);\n\nif ($dbConfig->profiler) {\n\n}\n\\--\n\n*riadok s kódom **Environment::loadConfig()** zmažte z **app/bootstrap.php**!*\n\nNakoniec je nutné niekam uložiť konfiguráciu (umiestnenie) pracovných zložiek pre konzolové rozhranie. **doctrine-cli** si ich vo vhodný moment z tohto miesta vytiahne a využije pre svoje fungovanie. Ako najvhodnejší kandidát na úschovu týchto údajov sa javí globálne dostupná statická trieda Nette\\Environment, ktorá je na takéto účely priamo určená. Pridajte do **app/bootstrap.db.php** následujúci kód (súbor môžete následne zavrieť)\n\n/--php\nEnvironment::setVariable(\'doctrine_config\',\n    array(\n        \'data_fixtures_path\' => dirname(__FILE__) . \'/doctrine/data/fixtures\',\n        \'models_path\'        => dirname(__FILE__) . \'/models\',\n        \'migrations_path\'    => dirname(__FILE__) . \'/doctrine/migrations\',\n        \'sql_path\'           => dirname(__FILE__) . \'/doctrine/data/sql\',\n        \'yaml_schema_path\'   => dirname(__FILE__) . \'/doctrine/schema\'\n    )\n);\n\\--\n\n.[tip]\nSúbor **app/bootstrap.db.php** môžete využiť pri unit testoch ako bootstrapový súbor, ktorý vás pripojí k testovacej databáze.\n\nKonzolové rozhranie doctrine-cli\n===\nDo súboru **app/config.ini** pridajte sekciu *console*, ktorá bude dediť od sekcie *development*.\n\nAk pracujete na unixovom operačnom systéme, vytvorte v zložke **nette-doctrine/scripts** súbor **doctrine-cli** a nastavte mu spustiteľný príznak\n\n/--\ntouch scripts/doctrine-cli\nchmod +x scripts/doctrine-cli\n\\--\n\nNásledne do neho vložte kód\n\n/--\n#!/usr/bin/env php\n\n<?php\n\ndefine(\'APP_DIR\', dirname(__FILE__) . \'/../app\');\ndefine(\'LIBS_DIR\', dirname(__FILE__) . \'/../libs\');\n\nrequire dirname(__FILE__).\'/../app/bootstrap.db.php\';\n$cli = new Doctrine_Cli(Environment::getVariable(\'doctrine_config\'));\n$cli->run($_SERVER[\'argv\']);\n\\--\n\nSkúste teraz skript spustiť bez parametrov\n\n[* nette-doctrine-unix1.jpg *]\n\ndoctrine-cli a Windows\n---\nNa dosiahnutie rovnakej funkčnosti pod operačným systémom Windows musíte vyvinúť trocha viac úsilia. Predpokladajme, že máte Windows XP (pod Windows Vista a Windows 7 je postup len veľmi málo odlišný) a PHP máte nainštalované v zložke **C:\\php**. Túto zložku je nutné pridať do environment premennej PATH:\n- Klepnite pravým tlačidlom na ikonu \"Môj počítač\" a z menu vyberte na samom konci \"Vlastnosti\"\n- V novootvorenom okne klepnite na záložku \"Pokročilé\"\n- Nájdite tlačidlo \"Premenné prostredia\" a klepnite na neho\n- V novootvorenom okne v spodnej časti nalistujte premennú \"Path\" a klepnite na tlačidlo \"Editovať\"\n- K hodnote premennej pripíšte na koniec **;C:\\php** (vrátane bodkočiarky)\n\n[* nette-doctrine-win1.png *]\n\n- Posledné okno zavrite klepnutím na \"OK\" (ostatné okná ešte nezatvárajte)\n- V okne \"Premenné prostredia\" (druhé) rovnakým spôsobom nalistujte a editujte premennú \"PATHEXT\"\n- K jej hodnote na koniec pripíšte **;.PHP**\n\n[* nette-doctrine-win2.png *]\n\n- Všetky okná teraz pozatvárajte **klepnutím na \"OK\"**\n- Spustite konzolu **s právomocami administrátora**\n- Do konzoly zadajte tieto dva príkazy\n\n/--\nassoc .php=phpfile\nftype phpfile=\"C:\\php\\php.exe\" -f \"%1\" -- %~2\n\\--\n\nGratulujeme, práve ste *asociovali* súbory s príponou .php s vaším PHP interpretom. To znamená, že všetky súbory .php sú odteraz spustiteľné a predané do **C:\\php\\php.exe** na spracovanie.\n\nOstáva už iba vytvoriť konzolové rozhranie *doctrine-cli* vo vašom Windows operačnom systéme. Vytvorte súbor **nette-doctrine/scripts/doctrine-cli.php**. Jeho obsah je veľmi, veľmi podobný ako v prípade unixovej verzie\n\n/--\n<?php\n\ndefine(\'APP_DIR\', dirname(__FILE__) . \'/../app\');\ndefine(\'LIBS_DIR\', dirname(__FILE__) . \'/../libs\');\n\nrequire dirname(__FILE__).\'/../app/bootstrap.db.php\';\n$cli = new Doctrine_Cli(Environment::getVariable(\'doctrine_config\'));\n$cli->run($_SERVER[\'argv\']);\n\\--\n\nSkúste spustiť skript bez parametrov\n\n[* nette-doctrine-win4.png *]\n\ndoctrine-cli v akcii (vygeneruj mi Model)\n===\nUž letmý pohľad na výpis *doctrine-cli* prezrádza silu tohto skriptu. Doctrine prostredníctvom neho poskytuje silné nástroje automatizácie práce. Štruktúru vašej biznisovej logiky je možné zapísať (reprezentovať) troma rôznymi entitami\n- DB schéma\n- php Model\n- YAML konfiguračný súbor\n\nPrvé dva sú pre vašu aplikáciu nepostrádateľné a budú jej nedeliteľnou súčasťou. A hlavným kúzlom doctrine-cli je, že dokáže z jednej entity vygenerovať zvyšné dve\n\n[* triptich.png *]\n\ndoctrine-cli dokáže napr. z existujúcej databázy vygenerovať php kód Modelov. Alebo naopak, z YAML konfiguračného súboru dokáže pripraviť databázovú schému a php Modely (najčastejší model vývoja). Poďme sa na kúzlo tohto Doctrine triptychu pozrieť bližšie.\n\nV zložke **app/doctrine/schema** vytvorte súbor **schema.yml**. Súbory YAML (prípona .yml) sú konfiguračné súbory s formátom vysoko čitateľným pre človeka. Na rozdiel od XML súborov sa v nich človek dokáže zorientovať omnoho jednoduchšie a to dokonca keď sa jedná o stromové štruktúry. Súbor **app/doctrine/schema/schema.yml** definuje schému našej databázy (tabuľky a ich stĺpce). Poďme si takú jednoduchú schému vygenerovať\n\n/--\nEmployee:\n  columns:\n    name: string(50)\n  relations:\n    Phonenumbers:\n      type: many\n      class: Phonenumber\n      local: id\n      foreign: employee_id\n\nPhonenumber:\n  columns:\n    employee_id: integer\n    phonenumber: string(50)\n  relations:\n    Employee:\n      local: employee_id\n      foreign: id\n\\--\n\nAko vidíte, naša aplikácia bude obsahovať dve tabuľky s prepojením 1:N. Všimnite si definíciu tabuľky alebo ich prepojenia. Všetko je zreteľné na prvý pohľad. Skúste ešte definovať obsah týchto tabuliek, aby ste inštaláciu Doctrine mohli otestovať s nejakými demo údajmi\n\n**app/doctrine/data/fixtures/data.yml**\n/--\nEmployee:\n  Employee_1:\n    name: John Doe\n    Phonenumbers: [john_home, john_work, john_desk]\n  Employee_2:\n    name: Betty Lee\n    Phonenumbers: [betty_home, betty_work]\n\nPhonenumber:\n  john_home:\n    phonenumber: 555 123 456\n  john_work:\n    phonenumber: 332 546 789\n  john_desk:\n    phonenumber: 555 456 879\n  betty_home:\n    phonenumber: 555 649 879\n  betty_work:\n    phonenumber: 332 456 546\n\\--\n\nOpäť veľmi čitateľný zápis. Teraz už iba ostáva konfiguračné súbory predhodiť konzolovému rozhraniu doctrine-cli a nechať ho urobiť svoju prácu\n\n/--\n./scripts/doctrine-cli build-all-load\n\\--\n\n[* nette-doctrine-build1.png *]\n\nHoďte očkom prosím na vašu databázu, alebo do zložky **app/models**\n\n[* nette-doctrine-table1.png *]\n\n[* nette-doctrine-table2.png *]\n\nZapojte vaše vygenerované Modely do práce - nech vám napr. vylistujú všetky telefónne čísla, ktoré patria Johnovi. Dopíšte do **app/models/Employee.php** túto statickú metódu\n/--php\npublic static function getByName($name)\n{\n    $q = Doctrine_Query::create()\n        ->from(\'Employee e\')\n        ->leftJoin(\'e.Phonenumbers p\')\n        ->where(\'e.name = ?\', $name);\n\n    $result = $q->execute();\n    return ($result) ? $result : null;\n}\n\\--\n\nPráve ste použili DQL (Doctrine query language) - veľmi mocný dotazovací jazyk, ktorým vás Doctrine odtieňuje od rôznych enginov databáz. Využite túto metódu v niektorom presenteri a zobrazte si výsledok v šablóne. Editujte **app/presenters/HomepagePresenter.php** a do metódy *renderDefault* dopíšte\n\n/--php\n$this->template->employee = Employee::getByName(\'John Doe\');\n\\--\n\nDo šablóny tohto View dopíšte (do druhého DIVu)\n\n/--php\n<pre>{? print_r($employee->toArray())}</pre>\n\\--\n\na otvorte domovskú stránku projektu\n\n[* nette-doctrine-web.png *]\n\nGratulujeme, vaša prvá stránka vydolovala údaje z databázy v spolupráci s Doctrine. Možnosti samotnej práce s Modelmi ďaleko presahujú rámec tohto tutoriálu, preto si všetky pokročilé techniky prosím naštudujte v \"oficiálnej dokumentácii\":http://www.doctrine-project.org/documentation.\n\nProfiler\n===\nV úvode sme vám sľúbili aj postup ako Doctrine napojiť na profiler Nette Framework. Všímavejší istotne postrehli, že v súbore **app/bootstrap.db.php** sme si pre profiler pripravili miesto\n\n/--php\n$dbConfig = Environment::getConfig(\'database\');\n$conn = Doctrine_Manager::connection($dbConfig->driver . \'://\' . $dbConfig->username . \':\' . $dbConfig->password . \'@\' . $dbConfig->host . \'/\' . $dbConfig->database);\n\nif ($dbConfig->profiler) {\n    // tu príde kód\n}\n\\--\n\nDo prázdneho miesta dopíšte tento kód\n\n/--php\n    $profiler = new Doctrine_Connection_Profiler();\n    $conn->setListener($profiler);\n    Debug::enableProfiler();\n    Debug::addColophon(\'fetchDoctrineEvents\');\n\\--\n\nNa poslednom riadku sme do metódy *Debug::addColophon()* predali callback na funkciu *fetchDoctrineEvents*. Musíme ju teda doplniť do kódu. Napr. na samotný koniec suboru **app/bootstrap.db.php** (mimo horeuvedený IF!)\n\n/--php\nfunction fetchDoctrineEvents()\n{\n    $profiler = Doctrine_Manager::getInstance()->getCurrentConnection()->getListener();\n\n    $queries = 0;\n    $out = \'<br />\';\n    foreach ($profiler as $event) {\n        $evName = $event->getName();\n\n        if ($evName == \'execute\') {\n            $queries++;\n            $out .= \'[\' . number_format($event->getElapsedSecs() * 1000, 3) . \'ms]<br />\'. $event->getQuery() . \'<br />\';\n        }\n\n        $params = $event->getParams();\n        if(!empty($params)) {\n            $out .= print_r($params, true) . \'<br /><br />\';\n        }\n    }\n\n    return array(\n        $profiler->count() . \' Doctrine events\',\n        $queries . \' sql queries\',\n        $out\n    );\n}\n\\--\n\nSpustite hlavnú stránku ešte raz\n\n[* nette-doctrine-profiler.png *]\n\nZhrnutie\n===\nNáš tutoriál je na konci. naučili ste sa v ňom naprogramovať podporu ORM frameworku Doctrine do Nette Framework. Sprevádzkovali ste konzolové rozhramie *doctrine-cli* (užívatelia Windows okrem toho sprevádzkovali vykonávanie skriptov PHP v konzoli), zoznámili ste sa s konfiguráciou DB schémy a demo údajov pomocou súborov YAML. Pomocou *doctrine-cli* ste z týchto údajov vygenerovali DB schému a PHP Modely. Modely ste následne dokázali využiť v presenteroch Nette. A nakoniec ste prepojili Nette a Doctrine profiler a jeho údaje vykreslili na stránke.\n',	'cs',	0,	'public'),
  (89,	0,	'2015-04-24 20:20:50',	'2015-04-24 20:20:50',	1860,	'Statické ACL v modulárnej aplikácii',	'staticke-acl-v-modularnej-aplikacii',	'\n.[perex]\nV tomto tutoriáli sa naučíme vytvoriť modulárnu aplikáciu v Nette Framework, rozdelenú na **verejnú a admin sekciu**. Vstup a pohyb po admin sekcii bude kontrolovaný pomocou statického **ACL** (access control list). Ukážeme vám ako nastaviť ACL v súčinnosti s tzv. *roles*, *resources* a *privileges*.\n\n.[tip]\nTento tutoriál bol **1. 2. 2013** aktualizovaný pre **Nette 2.0.8**. Je dostupný na \"Gitu\":https://github.com/schmutzka/nette-acl.\n\nPro snazšie pochopenie vyzkúšajte \"demo\":http://nette-acl.schmutzka.eu/.\n\n\nPredhovor\n=========\nUžívatelia, ktorí začnú využívať niektorý webový PHP framework čoskoro zistia, že zložitejšiu aplikáciu je nutné rozdeliť na viac častí (modulov). Najčastejšie sa aplikácia rozdeľuje na dva moduly - *Frontend* a *Backend* (niekedy tiež označovaný ako administrácia).\n\n- **Frontend** je verejne prístupná časť aplikácie, ktorú vidí bežný návštevník.\n- **Backend** predstavuje uzavretú časť aplikácie, do ktorej majú mať prístup iba oprávnení užívatelia (admin, redaktor, moderátor). Pre verejnosť je uzavretá.\n- Oba moduly využívajú ten istý Model (DATA) na manipuláciu s biznis logikou aplikácie.\n\n[* appschema.png *]\n\nFrontend DATA zvyčajne iba zobrazuje (preto jednosmerná šípka), Backend poskytuje funkcie aj na ich manipuláciu (pridávanie, editovanie, mazanie). Až zložitejšie (WEB 2.0) aplikácie umožňujú manipuláciu s dátami aj na Frontende. Jedná sa vtedy napr. o pridávanie diskusných príspevkov bežnými návštevníkmi.\n\nČo to je ACL a načo ho potrebujeme\n==================================\n\nMnoho programátorov webových aplikácií už výraz ACL možno videlo, ale jej správne uchopiť a použiť vo webovej aplikácií. V [dokumentácii |doc:access-control#toc-autorizace] se možete dočítat o jeho základnej logike a principech. Ako jej zakomponovať do komplexnej webovej aplikácie si povíme tu.\n\nACL a Nette Framework\n---------------------\n\nNajjednoduchšie využitie ACL v Nette Framework je v súčinnosti s MVP konceptom. Ako zdroje použijeme názvy Presenterov a privilégia budú zastupovať názvy akcii/view metód.\n\n/--php\nif ($this->user->isAllowed($this->name, $this->view)) {\n	// chraneny kod\n}\n\\--\n\nČo budeme potrebovať?\n=====================\n1. Zo stránky \"Download\":http://nette.org/cs/download si stiahnite archív *Nette Framework 2.0.8 pro PHP 5.3+*\n2. Pred začatím si prosím otestujte svoj webový server pomocou nástroja **requirement-checker**, či disponuje šetkým, čo Nette pro svoj beh vyžaduje.\n3. Vytvorte si pracovnú zložku pre projekt, napr. **nette-acl**, a nakopírujte do ní obsah zložky `examples/Modules-Usage` zo stiahnutého archívu.\n4. Zkopírujeme *Authenticator.php*, ze složky `examples/CD-collection/app/model` do naší (tedy `nette-acl/app/model/`)\n\nČo najskor upravíme?\n---\n1. vytvorímte složku `libs`a pridáme do ní knižnicí Nette Framework (zložka `Nette` v balíku)\n2. v zložke `libs` ešte vytvorte jednoduchú štruktúru podadresárov s názvami `AclProj/Security`\n\n.[note]\nNázov *AclProj* predstavuje názov vášho projektu. V tejto zložke budú umiestnené definície vlastných tried projektu, tedy po namespacom *AclProj*. V reálnej situácii svoj projekt zvyčajne pomenujete nejakým zmysluplnejším menom. Toto meno použite ako názov namiesto *AclProj*.\n\n\nCelá štruktúra zložek vyzerá takto:\n\n/--\n/nette-acl\n	/app\n		/AdminModule\n		/FrontModule\n		/presenters\n	/libs\n		/AclProj\n			/Security\n		/Nette\n	/log\n	/temp\n	/www\n\\--\n\n3. nahradíme obsah súboru `libs/autoload.php` týmto:\n/--php\nrequire __DIR__ . \'/Nette/loader.php\';\n\\--\n\n4. do RobotLoaderu v `app/boostrap.php` pridáme adresár `libs`:\n/---php\n$configurator->createRobotLoader()\n	->addDirectory(__DIR__)\n	->addDirectory(__DIR__ . \'/../libs\') // pridajte tento riadok\n	->register();\n\\--\n\n5. do súboru `app/AdminModule/templates/@layout.latte` pridáme pod `<h1>Modules demo</h1>`:\n\n/---html\n<div n:foreach=\"$flashes as $flash\" class=\"flash flash-{$flash->type}\">\n	<p>{$flash->message}</p>\n</div>\n\n{if $user->isLoggedIn()}\n	{if $user->isAllowed(\'Admin:Page\')}\n		<a n:href=\"Page:\">Page</a> (can see only admin) |\n	{/if}\n	<a n:href=\"Page:\">Page</a> (can see everyone) |\n	logged as <em>{$user->getIdentity()->login}</em> (<a n:href=\"logout!\">logout</a>)\n\n{else}\n	<p>You are not logged in.</p>\n{/if}\n\\---\n\nTeraz už môžeme otestovať základnú funkčnosť aplikácie.\n\n.[tip]\nPokud niečo nefunguje, zkuste najskor premazať zložku **temp/cache**.\n\nZabezpečený Backend\n===================\nAko už bolo spomenuté vyššie, na riadenie prístupu do Backend modulu (v ďalšom texte bude použité spojenie *AdminModule* alebo *admin sekcia*) bude využívané statické ACL. Statické znamená, že všetky privilégia, zdroje a role budú zapísané v config súboru. Oprávnených užívateľov a ich roly si však uložíme do databázy a následne využijeme `Nette\\Database` na získanie týchto údajov z databáze.\n\n\nObsah databáze\n---\nVytvorte novú databázu (napr. **nette_acl**) a tabuľku *user*, ktorá bude udržiavať údaje o oprávnených užívateľoch. Všimnite si, že tabuľka obsahuje stĺpec *role*, kde je uložená rola užívateľa. Prihlasovacé jméno, heslo i rola má vždy stejnú hodnotu (pre názorňajšú ukázku).\n\nSpustite tento SQL príkaz nad vašou databázou, čím vytvoríte a naplníte tabuľku *users*.\n\n/--\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `login` varchar(255) NOT NULL,\n  `password` char(40) NOT NULL,\n  `role` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) DEFAULT CHARSET=utf8;\n\nINSERT INTO `user` (`login`, `password`, `role`) VALUES\n(\'admin\', sha1(\'admin\'), \'admin\'),\n(\'editor\', sha1(\'editor\'), \'editor\');\n\\--\n\nPripojenie k databázi\n---\n\nPripojenie ku databáze je potrebné nakonfigurovať ako službu. Bude tak kedykoľvek dostupné v systémovom [DI |doc:dependency-injection] kontajneri. Konfiguráciu zapíšte do `app/config.neon` (prihlasovacie údaje upravte podľa svojho DB servera).\n\n\n/--neon\ncommon:\n	parameters:\n		database:\n			driver: mysql\n			host: localhost\n			dbname: nette_acl\n			user: # doplnte meno\n			password: # doplnte heslo\n\n	services:\n		database:\n			class: Nette\\Database\\Connection\n			arguments: [\n				\'%database.driver%:host=%database.host%;dbname=%database.dbname%\',\n				%database.user%,\n				%database.password%\n			]\n\\--\n\nVytvorenie ACL\n--------------\n\nAko sme už spomenuli, ACL je v tomto tutoriáli zapísaný v config.neon ako služba *authorizator* vytvorená z \"Nette\\Security\\Permission\":api:Nette\\Security\\Permission. Jeho úlohou je definovanie rolí, zdrojov a oprávnení. Použité role sa musia zhodovať s rolami užívateľov uložených v databáze v tabuľke `user`.\n\n/--neon\nservices:\n	authorizator:\n		class: Nette\\Security\\Permission\n		setup:\n			- addRole(\'guest\')\n			- addRole(\'editor\')\n			- addRole(\'admin\')\n			- addResource(\'Admin:Default\')\n			- addResource(\'Admin:Page\')\n			- allow(\'editor\', \'Admin:Default\') # šetky akcie resource Admin:Default\n			- allow(\'admin\') # šetky resources a ich akcie\n\\--\n\nDetailne o dedení rolí, definici zdrojov specifikovanie privileges pojednává opet [dokumentácie |doc:access-control#toc-permission-acl].\n\nV tomto prípade sa jedná o najjednoduchšiu definíciu služby - keď si ktokoľvek od DIC vyžiada `authorizator`, dostane inštanciu `Nette\\Security\\Permission`.\n\nPrihlásenie\n---------------------------\n\nPro prihlásenie použijeme službu *authenticator* (umístenú v `app/models`), ktorý obstará overenie údajov zadaných do prihlasovacieho formulára oproti našej DB tabuľke. Službu je iba potreba zaregistrovať v `app/config.neon` a možme používať.\n\n/--neon\nservices:\n	authenticator: Authenticator\n\\--\n\n.[tip]\nPokud vás zaujímá, ako **presne authenticator funguje**, odporučám \"Quickstart - Přihlašování uživatelů\":doc:quickstart/authentication\n\n\nLogin action\n------------\nLogika aplikácie v AdminModule bude taká, že ak sa užívateľ pokúsi spustiť nějakú akciu:\n- overí sa, či je užívateľ prihlásený\n- ak nie je, bude presmerovaný na `AdminModule\\AuthPresenter:login`, ktorý mu zobrazí prihlasovací formulár\n- ak je užívateľ už prihlásený, aplikácia v súčinnosti s ACL overí, či má užívateľ oprávnenie spustiť žiadanú `Presenter:action`\n\n\nVytvorte najskôr `AdminModule\\BasePresenter`, od ktorého budú dediť všetky Presentre v AdminModule:\n\n**app/AdminModule/presenters/BasePresenter.php**\n/--php\nnamespace AdminModule;\n\nuse Nette\\Security\\User;\n\nabstract class BasePresenter extends \\BasePresenter\n{\n	public function startup()\n	{\n		parent::startup();\n\n		if ($this->name != \'Admin:Auth\') {\n			if (!$this->user->isLoggedIn()) {\n				if ($this->user->getLogoutReason() === User::INACTIVITY) {\n					$this->flashMessage(\'Session timeout, you have been logged out\');\n				}\n\n				$this->redirect(\'Auth:login\', array(\n					\'backlink\' => $this->storeRequest()\n				));\n\n			} else {\n				if (!$this->user->isAllowed($this->name, $this->action)) {\n					$this->flashMessage(\'Access denied\');\n					$this->redirect(\'Default:\');\n				}\n			}\n		}\n	}\n\n\n	/**\n	 * Logout user\n	 */\n	public function handleLogout()\n	{\n		$this->user->logOut();\n		$this->flashMessage(\'You were logged off.\');\n		$this->redirect(\'this\');\n	}\n\n}\n\\--\n\nV Presenteri sme prepísali metódu `startup()`. Ak sa pozorne pozrieme na [životný cyklus|doc:nette-application-presenter] Presentera, zistíme, že metóda `startup()` sa volá na úplnom začiatku behu Presentera. Ak teda chcete zabrániť vykonaniu akcie Presentera, musíme to urobiť práve tu.\n\nKód presne implementuje logiku, ktorú sme spomínali o pár odstavcov vyššie:\n- overí sa, či je užívateľ prihlásený\n- ak nie, overí sa či už neuplynul *logout interval*, v tomto prípade nastavíme flashMessage s informáciou\n- každý neprihlásený užívateľ je potom presmerovaný na `AdminModule:AuthPresenter:login`, ktorý zabezpečí vykreslenie prihlasovacieho formulára\n- predtým je ešte do Session uložený aktuálny request, vďaka čomu bude užívateľ po prihlásení hneď presmerovaný na *destination*, z ktorej sme ho v tomto kroku *vyhodili*\n- ak áno, je s pomocou ACL rozhodnuté či má užívateľ *privilégium* k *zdroju*\n\nAko ste si mohli všimnúť z popisu a kódu, neprihlásení užívatelia sú presmerovaní na `AdminModule:AuthPresenter:login`, kde sa im zobrazí prihlasovací formulár.\n\n**app/AdminModule/presenters/AuthPresenter.php**\n\n/--php\nnamespace AdminModule;\n\nuse Nette\\Application\\UI\\Form;\nuse Nette\\Security\\AuthenticationException;\n\nclass AuthPresenter extends BasePresenter\n{\n	/** @persistent */\n	public $backlink;\n\n\n	/**\n	 * Login form factory\n	 * @return Nette\\Application\\UI\\Form\n	 */\n	protected function createComponentLoginForm()\n	{\n		$form = new Form;\n		$form->addText(\'name\', \'Name:\')\n			->addRule(Form::FILLED, \'Enter login\');\n		$form->addPassword(\'password\', \'Password:\')\n			->addRule(Form::FILLED, \'Enter password\');\n		$form->addSubmit(\'send\', \'Log in\');\n\n		$form->onSuccess[] = $this->processLoginForm;\n		return $form;\n	}\n\n\n	/**\n	 * Process login form and login user\n	 * @param Nette\\Application\\UI\\Form\n	 */\n	public function processLoginForm(Form $form)\n	{\n		$values = $form->getValues(TRUE);\n		try {\n			$this->user->login($values[\'name\'], $values[\'password\']);\n			$this->restoreRequest($this->backlink);\n			$this->redirect(\'Default:default\');\n\n		} catch (AuthenticationException $e) {\n			$form->addError($e->getMessage());\n		}\n	}\n\n}\n\\--\n\nMetoda `processLoginForm`sa vykoná iba ak je odoslaný formulár valídny (prejde validačnými pravidlami definovanými v konštruktore formulára). V tele callback funkcie sa pokúsime užívateľa prihlásiť (na pozadí sa zavolá metóda *authenticate()* z nášho *Authenticatora* viď. vyššie). V prípade, že je prihlásenie úspešné, užívateľ je presmerovaný späť.\n\nVšimnite, si že volanie **$user->login()** je obalené try/catch blokom. Ak teda metóda *authenticate()* vyhodí nejakú výnimku (a že ich vyhadzuje sa presvedčte vyššie v definícii triedy **AclProj\\Security\\Authenticator**), je message výnimky vložená do formulára a ten je nanovo vykreslený užívateľovi (samozrejme užívateľa neprihlásime), kde je o svojej chybe informovaný.\n\nOstáva doplniť kód šablóny `AuthPresentera`, kde sa nachádza vykreslenie prihlasovacieho formulára.\n\n**app/AdminModule/templates/Auth/login.latte**\n\n/--html\n{block #content}\n{control loginForm}\n\\--\n\nVyzkušajte\n===\n\nTeraz sa už môžete vyskúšať prihlásiť do admin sekcie\n- klikněte na odkaz *:Admin:Default:*\n- ak sa chcete prihlásiť ako admin zadajte login **admin** a heslo **admin**.\n\nAby ste mohli vyskúšať funkciu ACL, je treba do AdminModulu pridať další Presenter, ktorý je definovaný v ACL.\n\n**app/AdminModule/presenters/PagePresenter.php**\n\n/--php\nnamespace AdminModule;\n\nclass PagePresenter extends DefaultPresenter\n{\n\n}\n\\--\n\n**app/AdminModule/templates/Page/default.latte**\n\n/--html\n{block #content}\nYes! You can access to <strong>{$presenter->name}:{$presenter->view}</strong>\n\\--\n\nOtestuje prístup na nový Presentery pomocou obou užívateľov. Odhláste administratora a prihláste sa ako **editor**. *Editor* má podľa ACL povolenie na pohyb po **DefaultPresenter**. Nemá oprávnenie na vstup do **PagePresenter**. Skúste klepnúť na jeho odkaz a uvidíte čo sa stane. Zapracoval ACL a Presenter ochránil pred nepovoleným vstupom neoprávenej role. Aplikácia je v tomto momente hotová.\n',	'cs',	0,	'public'),
  (90,	0,	'2015-04-24 20:26:06',	'2015-04-24 20:26:06',	2127,	'Vytváříme kontaktní formulář',	'vytvarime-kontaktni-formular',	'\n.[perex]\nVytvoření kontaktního formuláře s odesláním na mail - formou **raw textu** i **html šablonou**.\n\n.[note]\nNávod staví nad sandboxem **Nette 2.0.8** a PHP 5.3+. Stačí jej stáhout a upravovat konkrétní soubory.\n\n\nJednoduše v presenteru\n===\n\nNejjednodušší a nejrychlejší přístup je vytvoření formuláře v presenteru - vytvoříme tedy komponentu `ContactForm`. Dále přidáme její zpracování třídou [Nette\\Mail\\Message|api:Nette\\Mail\\Message], která má na starosti vytváření a odesílání emailů. Více o odesílání emailů si můžete přečíst v [dokumentaci|doc:cs:mailing].\n\n\n**presenters/HomepagePresenter.php**\n\n/---php\nuse Nette\\Application\\UI\\Form;\nuse Nette\\Mail\\Message;\n\nclass HomepagePresenter extends BasePresenter\n{\n\n	/**\n	 * Contact form\n	 */\n	protected function createComponentContactForm()\n	{\n		$form = new Form;\n		$form->addText(\'name\', \'Jméno:\')\n			->addRule(Form::FILLED, \'Zadejte jméno\');\n		$form->addText(\'email\', \'Email:\')\n			->addRule(Form::FILLED, \'Zadejte email\')\n			->addRule(Form::EMAIL, \'Email nemá správný formát\');\n		$form->addTextarea(\'message\', \'Zpráva:\')\n			->addRule(Form::FILLED, \'Zadejte zprávu\');\n		$form->addSubmit(\'send\', \'Odeslat\');\n\n		$form->onSuccess[] = $this->processContactForm;\n\n		return $form;\n	}\n\n\n	/**\n	 * Process contact form, send message\n	 * @param Form\n	 */\n	public function processContactForm(Form $form)\n	{\n		$values = $form->getValues(TRUE);\n\n		$message = new Message;\n		$message->addTo(\'test@gmail.com\')\n			->setFrom($values[\'email\'])\n			->setSubject(\'Zpráva z kontaktního formuláře\')\n			->setBody($values[\'message\'])\n			->send();\n\n		$this->flashMessage(\'Zpráva byla odeslána\');\n		$this->redirect(\'this\');\n	}\n\n}\n\n\\---\n\n\nTakto vytvořenou komponentu poté stačí přidat do šablony a můžeme vesele kontaktovat.\n\n**templates/Homepage/default.latte**\n\n/--html\n{block #content}\n\n{control contactForm}\n\\--\n\n\nHtml šablona emailu\n---\n\nPokud chceme v emailu využít html, musíme použít vlastní šablonu. V ní definujeme proměnné (ty jí musíme předat) a předmět v tagu `<title>`. Šablonu umístíme např. do:\n\n**templates/email/emailTemplate.latte**\n\n/--html\n<html>\n	<head>\n		<title>{$title}</title>\n	</head>\n\n	<body>\n		<ul>\n			<li>\n				<strong>Jméno:</strong> {$values[\'name\']}\n			</li>\n			<li>\n				<strong>Email:</strong> {$values[\'email\']}\n			</li>\n			<li>\n				<strong>Zpráva:</strong> {$values[\'message\']}\n			</li>\n		</ul>\n\n	</body>\n</html>\n\\--\n\nJeště upravíme metodu pro zpracování formuláře.\n\n**presenters/HomepagePresenter.php**\n\n\n/--php\n\n/**\n * Process contact form, send message with custom template\n * @param Form\n */\npublic function processContactForm(Form $form)\n{\n	$values = $form->getValues(TRUE);\n\n	$message = new Message;\n	$message->addTo(\'test@gmail.com\')\n		->setFrom($values[\'email\']);\n\n	$template = $this->createTemplate();\n	$template->setFile(__DIR__ . \'/../templates/emails/emailTemplate.latte\');\n	$template->title = \'Zpráva z kontaktního formuláře\';\n	$template->values = $values;\n\n	$message->setHtmlBody($template)\n		->send();\n\n	$this->flashMessage(\'Zpráva byla odeslána\');\n	$this->redirect(\'this\');\n}\n\\--\n\n\n\n\n\n\n\n\n/---comment\nJako komponenta\n===\n\nEmail s šablonou v komponentě\n\n\nŠikovná komponenta\n---\n\nFormuláře je vhodné pro přehlednost a lepší rozšiřitelnost umisťovat do samostatné složky, např. `app/forms`. Jelikož v tomto návodu bude potřeba vytváření šablon, využijeme k tomu samostatnou komponentu, kterou umístíme do `app/components`.\n\nZde vytvoříme složku `ContactFormControl` a v ní soubory:\n\n**ContactFormControl.php**\n\n/-php\nuse Nette\\Application\\UI\\Control;\nuse Nette\\Application\\UI\\Form;\nuse Nette\\Mail\\Message;\n\nclass ContactFormComponent extends Control\n{\n\n	protected function createComponentContactForm()\n	{\n		$form = new Form;\n		$form->addText(\'name\', \'Jméno:\')\n			->addRule(Form::FILLED, \'Zadejte jméno\');\n		$form->addText(\'email\', \'Email:\')\n			->addRule(Form::FILLED, \'Zadejte email\')\n			->addRule(Form::EMAIL, \'Email nemá správný formát\');\n		$form->addTextarea(\'message\', \'Zpráva:\')\n			->addRule(Form::FILLED, \'Zadejte zprávu\');\n		$form->addSubmit(\'send\', \'Odeslat\');\n\n		$form->onSuccess[] = $this->processContactForm;\n\n		return $form;\n	}\n\n\n	public function processContactForm(Form $form)\n	{\n		$settings = $this->presenter->context->parameters[\'email\'];\n		$values = $form->values;\n\n		$message = new Message;\n		$message->addTo($settings[\'to\'])\n			->setFrom($values[\'email\']);\n\n		// 1. způsob - raw text\n		$message->setSubject($settings[\'subject\'])\n			->setBody($values[\'message\']);\n\n		// 2. způsob - html\n		$template = $this->createTemplate();\n		$template->setFile(__DIR__ . \'/emailTemplate.latte\');\n		$template->title = $settings[\'subject\'];\n		$template->values = $values;\n		$message->setHtmlBody($template);\n\n		$message->send();\n\n		$this->presenter->flashMessage(\'Zpráva byla odeslána\');\n		$this->redirect(\'this\');\n	}\n\n\n	public function render()\n	{\n		$this->template->setFile(__DIR__ . \'/ContactFormControl.latte\');\n		$this->template->render();\n	}\n\n}\n\n\n\n**ContactFormControl.latte**\n/-html\n{control contactForm}\n\n\n**emailTemplate.latte**\n/-html\n<html>\n	<head>\n		<title>{$title}</title>\n	</head>\n\n	<body>\n		<ul>\n			<li>\n				<strong>Jméno:</strong> {$values[\'name\']}\n			</li>\n			<li>\n				<strong>Email:</strong> {$values[\'email\']}\n			</li>\n			<li>\n				<strong>Zpráva:</strong> {$values[\'message\']}\n			</li>\n		</ul>\n\n	</body>\n</html>\n\\-\n\n\n\nPresenter\n---\n\nPoté formulář zavoláme v presenteru a vytvoříme komponentu:\n\n**HomepagePresenter.php**\n\n/-php\nclass HomepagePresenter extends BasePresenter\n{\n\n	protected function createComponentContactFormControl()\n	{\n		return new ContactFormComponent;\n	}\n\n\n}\n\n\\-\n\n\nŠablona\n---\n\nKomponentu přidáme do šalbony:\n\n**Homepage/default.latte**\n/-html\n{block content}\n	{control contactFormControl}\n{/block}\n\\-\n\nConfig\n---\n\n**app/config/config.neon**\n/-php\ncommon:\n	parameters:\n		email:\n			to: my@email.com\n			subject: Kontaktní formulář\n\\-\n\nSMTP odesílání?\n---\n\nLink někam, toto už tu je...\n\n\\--',	'cs',	0,	'public'),
  (91,	0,	'2015-04-24 20:27:20',	'2015-04-24 20:27:20',	3363,	'Route – deklarace parametru obsahující lomítka',	'route-deklarace-parametru-obsahujici-lomitka',	'\n.[perex]\nTento článek ukazuje, jak vytvořit routu, která **akceptuje lomítka v url**, například pro stahování souborů nebo hiarchickou navigaci. Využijeme k tomu třídu [Nette\\Application\\Route | api:].\n\nVychází z \"tohoto tématu na fóru\":http://forum.nette.org/cs/6530-dynamicka-routa-pro-clanky. Také se snažím vysvětlit rozdíly mezi jednotlivými zápisy **a vysvětlit trochu práci s  metadaty parametrů třídy Route**.\n\nCíl\n=====\nChceme, aby URL `http://server.com/produkty/elektro/zarovky/` se přeložilo  na [Nette\\Application\\PresenterRequest | api:] s parametry:\n|Presenter| Page\n|action| default\n|node| `produkty/elektro/zarovky/`\n\nZačínáme\n====\nNastavíme router. Zkusíme toto:\n/--php\n$Ro[] = new Route(\"<node>\", array(\n	    \"presenter\" => \"Page\",\n	    \"action\" => \"default\",\n	));\n\\--\n\n.[note]\nJen připomenu část citátu : *\"but still voodoo\"*\n\n**Bohužel to nyní nejde.** Pohledem do api [Nette\\Application\\Route::$styles |api:] zjistíme, že výchozí nastavení (styl) pro parametry v cestě(kromě presenter, action a parametrů v querystringu) má *metadata*, která se nehodí pro náš parametr.\n-výchozí \"vzor=PATTERN\"(([^/]+)) neakceptuje lomítka. Na vhodném místě v kódu ho měníme ho tedy na .*\n-Ani tak to nebude fungovat -- lomítka se totiž převedou na %2F -- díky \"FILTER_OUT\"((rawurlencode)). Taktéž na vhodném místě změníme funkci: na \"funkci, která vrací řetězec, který dostane\"((function($s){return $s;})). **Ovšem pokud místo funkce uvedeme //null//, tak dosáhneme stejného efektu**.\n\n.[note]\nPřipomenu, co to jsou *metadata*. To jsou de facto vlastnosti daného PARAMETRu v Routě.\nJsou to tyto\n|význam|zápis|hodnota konstanty|datový typ\n|-----------------------------\n|výchozí hodnota|*Route::VALUE|value|string\n|regulerní výraz|*Route::PATTERN|pattern|string\n|vstupní filtr((transfomuje parametr z url na parametr PresenenterReqeustu))|*Route::FILTER_IN|filterIn|funkce\n|výstupní filtr((transformuje parametr z Pres.Req. na param v url))|*Route::FILTER_OUT|filterOut|funkce\n|filtrovací(překladová) tabulka((kombinace a zjednodušení předchozích dvou - klíče jsou, to co se zadá do url, a hodnoty, co dostane PresenterRequest))|*Route::FILTER_TABLE|filterTable|pole\n|\"interní - nepoužívat\"((určuje zda je povinný parametr, v naprosté většině případů není potřeba))|není,|fixity| |\n\n Ty se uvádějí těmito způsoby(pro parametry v query stringu platí jinačí pravidla):\n- v definici parametru v masce přímo v ostrých závorkách `<PARAMETR[=VALUE] [PATTERN] [#class]>` Class popíšu dále,\n - - tímto způsobem nelze přímo v masce určit filtry a překladovku.\n- v druhém parametru konstruktoru Route, což je pole(jmenuje se $metadata), kde klíče jsou názvy PARAMETRů. Dále se to liší, zda je hodnotou pole nebo string.\n - pole: \'node\'=>array(Route::VALUE=>...,Route::FILTER_TABLE=>...). Danému parametru přiřazujeme metadata z tabulky výše.\n  - jako podmožnost uvádím, kdy metadata se určí staticky pro daný parametr. Viz možnost 3.\n - string:pokud uvedeme `\'node\'=>\"about-us\"`, tak se to pokládá za výchozí hodnotu. Jinými slovy se to převede na  `\'node\'=>array(Route::VALUE=>\"about-us\")`\n- Pomocí class: class neboli styl jsou defacto připravená sada hodnot VALUE, PATTERN, FILTRů nebo překladové tabulky. Její ukázka bude v 4. možnosti.\n\nPozor: gramaticky se deklarace stylu liší jen o křížek, ale možnost bez křížku platí pro daný parametr zatímco s křížkem platí pro parametry, které označíme takto: <jmeno #style1>/<akce #style1>\n\n\n\nViz [Nette\\Application\\Route::VALUE |api:]\n\nŘešení\n=====\nVždy sledujeme, abychom nastavili dvě věci: PATTERN .* a FILTER_OUT.\n1)\n-----------\nUvedeme obojí v poli metadata.\n/--php\n$router[] = new Route(\"<node>\", array(\n	\"presenter\" => \"Page\",\n	\"action\" => \"default\",\n	\"node\" => array(\n		Route::FILTER_OUT => function ($uri) { return $uri; },\n		Route::PATTERN => \".*\",\n	),\n));\n\\--\n\n1a)\n-----------\nTotéž, jen filtr změníme na null. Taky pattern .* je nahrazen .*?, takže  zmizí poslední lomítko.\n/--php\n$router[] = new Route(\"<node>\", array(\n	\"presenter\" => \"Page\",\n	\"action\" => \"default\",\n	\"node\" => array(\n		Route::FILTER_OUT => NULL, // to má stejný efekt: přebije se výchozí hodnota rawurlencode,\n		                           // ale nevyhoví podmínce isset(), tudíž se parametr nezmění\n		Route::PATTERN => \".*?\",\n	),\n));\n\\--\n\n2)\n-----------\nPATTERN jsme přesunuli rovnou do deklarace masky. Stejná funkčnost.\n/--php\n$router[] = new Route(\"<node .*>\", array(\n	\"presenter\" => \"Page\",\n	\"action\" => \"default\",\n	\"node\" => array(\n		Route::FILTER_OUT => NULL,\n	),\n));\n\\--\n\n3)\n-----------\n**Poznámka**: Místo `Route::$styles[\'node\'] = ...` se spíš používá Route::addStyle() a Route::setStyleProperty().\n\nDeklarujeme metadata pro  parametr node \"předem\".\n/--php\nRoute::$styles[\'node\'] = array(\n    Route::FILTER_OUT => null,\n    Route::PATTERN => \".*?\",\n);\n$router[] = new Route(\"<node>\", array(\n	\"presenter\" => \"Page\",\n	\"action\" => \"default\",\n));\n\\--\n\n4)\n-----------\nDeklarujeme styl  #raw, který potom použijeme pro node.\n/--php\nRoute::$styles[\'#raw\'] = array(\n    Route::FILTER_OUT => null,\n    Route::PATTERN => \".*?\",\n);\n$router[] = new Route(\"<node #raw>\", array(\n	\"presenter\" => \"Page\",\n	\"action\" => \"default\",\n));\n\\--\n\n.[tip]\nPokud chcete, aby cesta nekončila lomítkem, tak místo `.*` pište `.*?`.\n',	'cs',	0,	'public'),
  (92,	0,	'2015-04-24 20:28:15',	'2015-04-24 20:28:15',	2118,	'Routování: Více parametrů ve filtru',	'routovani-vice-parametru-ve-filtru',	'\n.[perex]\nNěkdy nastává situace, kdy je potřeba dostat do filtru routy více parametrů, ale na to neexistuje nativní implementace. Jednu hotovou Vám tady teď představím.\n\n\nProblém\n=======\n\nJak dostanu do filtru jazyk, například na překlad stránky? Chci adresy takto:\n\n- `/cs/nejaky-clanek`\n- `/en/some-article`\n\n/--- code php\nuse Nette\\Application\\Route;\n\n\n$router[] = new Route(\'[!<lang>]/[!<article [a-z-]+>]\', array(\n	\'presenter\' => \'Article\',\n	\'action\' => \'default\',\n	\'article\' => array(\n		Route::FILTER_IN => callback(\'ArticleModel::slugToId\'),\n		Route::FILTER_OUT => callback(\'ArticleModel::idToSlug\')\n	),\n	\'lang\' => \'cs\',\n));\n\\---\n\n`ArticleModel`\n/--- code php\nstatic function slugToId($slug)\n{\n	$translator = Nette\\Environment::getService(\'ITranslator\');\n	// a jaký jazyk? vždyť ten je v adrese!\n	// ale na proměnnou $lang z routeru zde nevidím!\n\n	// a máme problém ...\n\n	return $id;\n}\n\\---\n\nV tomto okamžiku neznám jazyk, což je problém, protože nevím, jestli mám `article` překládat z \"nejaky-clanek\", nebo \"some-article\". Někteří by mohli namítat, že můžu prohledat i anglické i české názvy, ale to není moc hezké řešení.\n\nA to je jenom velice jednoduchý příklad. Všechno může být v některých situacích mnohem komplikovanější.\n\n\nŘešení\n======\n\nMyslím, že výsledný kód řekne více než tisíc slov :)\n\n\n/--- code php\n\n\nuse Nette\\Application\\Request;\n\nclass FilterRoute extends Nette\\Application\\Routers\\Route\n{\n\n    const WAY_IN = \'in\';\n    const WAY_OUT = \'out\';\n\n    // překlad a vyhledání v databázi\n    /** @var array */\n    private $filters = array();\n\n    /**\n     * @param Nette\\Web\\IHttpRequest $httpRequest\n     * @return Nette\\Application\\Request|NULL\n     */\n    public function match(Nette\\Http\\IRequest $httpRequest)\n    {\n        $appRequest = parent::match($httpRequest);\n        if (!$appRequest) {\n            return $appRequest;\n        }\n\n        if ($params = $this->doFilterParams($this->getRequestParams($appRequest), $appRequest, self::WAY_IN)) {\n            return $this->setRequestParams($appRequest, $params);\n        }\n\n        return NULL;\n    }\n\n    /**\n     * @param Nette\\Application\\Request $appRequest\n     * @param Nette\\Web\\Uri $refUri\n     * @return string\n     */\n    public function constructUrl(Request $appRequest, Nette\\Http\\Url $refUrl)\n    {\n        if ($params = $this->doFilterParams($this->getRequestParams($appRequest), $appRequest, self::WAY_OUT)) {\n            $appRequest = $this->setRequestParams($appRequest, $params);\n            return parent::constructUrl($appRequest, $refUrl);\n        }\n\n        return NULL;\n    }\n\n    /**\n     * @param string $param\n     * @param callable $in\n     * @param callable $out\n     * @return SmarterRoute\n     */\n    public function addFilter($param, $in, $out = NULL)\n    {\n        $this->filters[$param] = array(\n            self::WAY_IN => callback($in),\n            self::WAY_OUT => $out ? callback($out) : NULL\n        );\n\n        return $this;\n    }\n\n    /**\n     * @return array\n     */\n    public function getFilters()\n    {\n        return $this->filters;\n    }\n\n    /**\n     * @param Nette\\Application\\Request $appRequest\n     * @return array\n     */\n    private function getRequestParams(Request $appRequest)\n    {\n        $params = $appRequest->getParameters();\n        $metadata = $this->getDefaults();\n\n        $presenter = $appRequest->getPresenterName();\n        $params[self::PRESENTER_KEY] = $presenter;\n\n        if (isset($metadata[self::MODULE_KEY])) { // try split into module and [submodule:]presenter parts\n            $module = $metadata[self::MODULE_KEY];\n            if (isset($module[\'fixity\']) && strncasecmp($presenter, $module[self::VALUE] . \':\', strlen($module[self::VALUE]) + 1) === 0) {\n                $a = strlen($module[self::VALUE]);\n            } else {\n                $a = strrpos($presenter, \':\');\n            }\n\n            if ($a === FALSE) {\n                $params[self::MODULE_KEY] = \'\';\n            } else {\n                $params[self::MODULE_KEY] = substr($presenter, 0, $a);\n                $params[self::PRESENTER_KEY] = substr($presenter, $a + 1);\n            }\n        }\n\n        return $params;\n    }\n\n    /**\n     * @param Nette\\Application\\Request $appRequest\n     * @param array $params\n     * @return Nette\\Application\\Request\n     */\n    private function setRequestParams(Request $appRequest, array $params)\n    {\n        $metadata = $this->getDefaults();\n\n        if (!isset($params[self::PRESENTER_KEY])) {\n            throw new \\InvalidStateException(\'Missing presenter in route definition.\');\n        }\n        if (isset($metadata[self::MODULE_KEY])) {\n            if (!isset($params[self::MODULE_KEY])) {\n                throw new \\InvalidStateException(\'Missing module in route definition.\');\n            }\n            $presenter = $params[self::MODULE_KEY] . \':\' . $params[self::PRESENTER_KEY];\n            unset($params[self::MODULE_KEY], $params[self::PRESENTER_KEY]);\n        } else {\n            $presenter = $params[self::PRESENTER_KEY];\n            unset($params[self::PRESENTER_KEY]);\n        }\n\n        $appRequest->setPresenterName($presenter);\n        $appRequest->setParameters($params);\n\n        return $appRequest;\n    }\n\n    /**\n     * @param array $params\n     * @param Nette\\Application\\Request $request\n     * @param string $way\n     */\n    private function doFilterParams($params, Request $request, $way)\n    {\n        // tady mám k dispozici všechny parametry\n        foreach ($this->getFilters() as $param => $filters) {\n            if (!isset($params[$param]) || !isset($filters[$way])) {\n                continue; // param not found\n            }\n\n            $params[$param] = call_user_func($filters[$way], (string) $params[$param], $request);\n            if ($params[$param] === NULL) {\n                return NULL; // rejected by filter\n            }\n        }\n\n        return $params;\n    }\n\n}\n\\---\n\n\nPoužití\n=======\n\n/--- code php\n$router[] = $route = new FilterRoute(\'<presenter>/<action>\', array(...));\n$route->addFilter(\'id\', \'PageModule::uriToId\', \'PageModule::idToUrl\');\n\\---\n\nupravená metoda v `ArticleModel`\n/--- code php\nstatic function slugToId($slug, Nette\\Application\\PresenterRequest $request)\n{\n        $translator = Nette\\Environment::getService(\'ITranslator\');\n        $lang = $request->params[\'lang\']; // zkratka na $request->getParams()\n\n        // překlad a vyhledání v databázi\n\n        return $id;\n}\n\\---\n\nFígl je v tom, že Router zpracuje adresu normálně a filtračním funkcím předává parametr i výsledný \"PresenterRequest\":http://api.nette.org/2.0/Nette.Application.PresenterRequest.html a následně vracenými hodnotami přepíše původní.\n',	'cs',	0,	'public'),
  (93,	12,	'2015-04-24 20:30:16',	'2015-04-24 20:30:16',	1657,	'Jak zprovoznit TinyMCE v Nette',	'jak-zprovoznit-tinymce-v-nette',	'**Užitečné odkazy**\n- [Oficiální web TinyMCE | http://www.tinymce.com/]\n- [Konfigurace | http://www.tinymce.com/wiki.php/Configuration]\n\nNavěšení TinyMCE na textareu\n============================\n\nPomocí třídy (doporučeno)\n------------\n/--php\n$form->addTextArea(\'text\', \'Text\')\n	->setAttribute(\'class\', \'mceEditor\');\n\\--\n\n/--js\ntinyMCE.init({\n	mode: \"specific_textareas\",\n	editor_selector: \"mceEditor\",\n	...\n});\n\\--\n\nPomocí ID\n---------\n/--php\n$form->addTextArea(\'text\', \'Text\')\n	->setHtmlId(\'mceEditor\');\n\\--\n\n/--js\ntinyMCE.init({\n	mode: \"exact\",\n	elements: \"mceEditor\",\n	...\n});\n\\--\n\nZprovoznění validace\n====================\nAby bylo možné používat na textareu s TinyMCE validaci, je nutné zajistit, aby se před Nette validací uložil napsaný text do textarey.\n\nPokud je ve formuláři jen jedno tlačítko, nebo je jich tam více, ale všemi se spouští validace, tak lze uložení obsahu navázat na `onSubmit` formuláře.\n\n/--php\n$form->getElementPrototype()->onsubmit(\'tinyMCE.triggerSave()\');\n\\--\n\n\n/--comment\nNásledují text / kód jsem nikdy netestoval, ale čistě hypoteticky by mohl fungovat.\n\\--\n\nPokud jedno z tlačítek validaci nespouští (třeba tlačítko \"Zpět\", nastavuje se pomocí metody [setValidationScope | api:Nette\\Forms\\SubmitButton::setValidationScope()]), tak je validace navázána na onClick těch tlačítek, které validaci spouští.\n\n/--php\nforeach ($form->getComponents(TRUE, \'SubmitButton\') as $button) {\n	if (!$button->getValidationScope()) continue;\n	$button->getControlPrototype()->onclick(\'tinyMCE.triggerSave()\');\n}\n\\--\n\n',	'cs',	0,	'public'),
  (94,	12,	'2015-04-24 20:30:54',	'2015-04-24 20:30:54',	1657,	'How to configure TinyMCE in Nette',	'how-to-configure-tinymce-in-nette',	'\n**Usefull links**\n- [Official site TinyMCE | http://www.tinymce.com/]\n- [Configuration| http://www.tinymce.com/wiki.php/Configuration]\n\nAttach TinyMCE to textarea\n============================\n\nBy class (recommended)\n------------\n/--php\n$form->addTextArea(\'text\', \'Text\')\n	->setAttribute(\'class\', \'mceEditor\');\n\\--\n\n/--js\ntinyMCE.init({\n	mode: \"specific_textareas\",\n	editor_selector: \"mceEditor\",\n	...\n});\n\\--\n\nBy ID\n---------\n/--php\n$form->addTextArea(\'text\', \'Text\')\n	->setHtmlId(\'mceEditor\');\n\\--\n\n/--js\ntinyMCE.init({\n	mode: \"exact\",\n	elements: \"mceEditor\",\n	...\n});\n\\--\n\n\nConfiguring validation\n====================\nTo enable validation in textarea with TinyMCe it is important to save written text to textarea before Nette validation.\n\nIf a form contains only one button (or if all buttons runs validation) you can attach text saving on `onSubmit` of the form.\n\n/--php\n$form->getElementPrototype()->onsubmit(\'tinyMCE.triggerSave()\');\n\\--\n\n\n/--comment\nFollowing is not tested, but hypothetically should work.\n\\--\n\nIf one of the buttons doesn\'t run validation (i.e., \"Back\", set up by [setValidationScope | api:Nette\\Forms\\SubmitButton::setValidationScope()]), validation is attached to `onClick` of those buttons, which run the validation.\n\n/--php\nforeach ($form->getComponents(TRUE, \'SubmitButton\') as $button) {\n	if (!$button->getValidationScope()) continue;\n	$button->getControlPrototype()->onclick(\'tinyMCE.triggerSave()\');\n}\n\\--\n',	'en',	0,	'public'),
  (95,	0,	'2015-04-24 20:32:05',	'2015-04-24 20:32:05',	3705,	'Hosting neumožňuje změnu root složky',	'hosting-neumoznuje-zmenu-root-slozky',	'Poměrně často narazíte na sdílený hosting, který Vám neumožní změnit root adresář (respektive určí vám, do kterého adresáře musíte nahrát aplikaci). Sandbox Nette nicméně předpokládá, že rootem bude složka `www`.\n\nExistuje jednoduché řešení. Všechny požadavky necháte směrovat do podsložky `www`. Vyžaduje web server Apache s aktivním `mod_rewrite`.\n\n/--code\nRewriteEngine On\nRewriteCond %{HTTP_HOST} ^(www\\.)?example\\.com$\nRewriteRule ^$ www/ [L]\nRewriteCond %{HTTP_HOST} ^(www\\.)?example\\.com$\nRewriteRule (.*) www/$1 [L]\n\\--\n\nObě výše uvedené direktivy `RewriteCond` nejsou nutné, nicméně jejich existenci uvítáte ve chvíli, kdy budete projekt vyvíjet lokálně.\n\n.[warning]\nNezapomeňte zkontrolovat, zda *app*, *libs*, *log* a *temp* obsahují *\".htaccess\"((pokud používáte IIS, tak se jedná o web.config))* se zákazem přístupu do těchto složek, aby vám někdo nemohl **přečíst konfigurační soubory či logy s chybami**.\n (Např. `http://example.com/app/config/config.neon`)\n',	'cs',	0,	'public'),
  (96,	0,	'2015-04-24 20:33:12',	'2015-04-24 20:33:12',	3705,	'Bílá stránka po nahrání na hosting',	'bila-stranka-po-nahrani-na-hosting',	'Postupně projdeme tyto kroky:\n\n1) smažeme obsah složky *temp/*,\n2) zkontrolujeme, zda je povolen zápis tam, kde má být povolen (tj. složky `log/` a `temp/`),\n3) zkusíme odkomentovat `RewriteBase` v *.htaccess*,\n4) zkontrolujeme logy (složka `logs/`),\n5) zapneme laděnku.\n\n',	'cs',	0,	'public'),
  (97,	0,	'2015-04-24 20:33:31',	'2015-04-24 20:33:31',	3705,	'Zrušení persistentního parametru',	'zruseni-persistentniho-parametru',	'Podíváme se do presenteru, jakou má nastavenou výchozí hodnotu:\n\n/--php\n/** @persistent int */\npublic $page;\n\\--\n\na tu mu předáme při vytváření odkazu:\n\n/--html\n<a href=\"{link someAction, page => NULL}\">someWhere</a>\n<!-- nebo -->\n<a n:href=\"someAction, page => NULL\">somweshWere</a>\n\\--\n',	'cs',	0,	'public'),
  (98,	0,	'2015-04-24 20:34:07',	'2015-04-24 20:34:07',	3705,	'Použítí `{}` v šabloně',	'pouziti-v-sablone',	'\nLatte filter používá `{}` jako \"řídící\" znaky. Pokud potřebujete v šabloně napsat `{}` (například u JavaScriptu), musíte za `{` udělat mezeru, pak následující část nebude brána jako makro.\n\nLze také použít Latte makra `{l}` resp. `{r}` pro vykreslení levé resp. pravé závorky.\n\n',	'cs',	0,	'public'),
  (99,	0,	'2015-04-24 20:34:43',	'2015-04-24 20:34:43',	3705,	'Texy!',	'texy',	'Na statické *Texy!* použijeme filter:\n\n/--php\npublic function templatePrepareFilters($template)\n{\n	parent::templatePrepareFilters($template);\n	$texy = new Texy();\n	$template->registerFilter(callback($texy, \'process\'));\n}\n\\--\n\nNa dynamické *Texy!* použijeme helper:\n\n/--php\nprotected function createTemplate($class = NULL)\n{\n	$template = parent::createTemplate($class);\n	$texy = new Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n\n	return $template;\n}\n\\--',	'cs',	0,	'public'),
  (100,	0,	'2015-04-24 20:35:15',	'2015-04-24 20:35:15',	3705,	'Odkazování v modulech',	'odkazovani-v-modulech',	'Do jiného modulu musíme odkázat pomocí absolutního názvu presenteru, tj. s dvojtečkou na začátku:\n\n/--html\n<!-- Relativní odkaz na modul -->\n<a href=\"{link Foo:Default:default}\">link</a>\n<!-- nebo -->\n<a n:href=\"Foo:Default:default\">link</a>\n\n<!-- Absolutní odkaz na modul -->\n<a href=\"{link :Foo:Default:default}\">link</a>\n<!-- nebo -->\n<a n:href=\":Foo:Default:default\">link</a>\n\\--\n',	'cs',	0,	'public'),
  (101,	0,	'2015-04-24 20:36:02',	'2015-04-24 20:36:02',	3705,	'Zapnutí laděnky v produkčním prostředí',	'zapnuti-ladenky-v-produkcnim-prostredi',	'Pokud z nějakého důvodu potřebujeme na produkčním serveru zapnout laděnku, v souboru `app/bootstrap.php` hned za vytvoření instance třídy `Configurator` přidáme((popř. upravíme existující)) tento řádek:\n\n/--php\n$configurator->setDebugMode(TRUE);\n\\--\n\n.[note]\nVe verzích starších než 2.0.3 se používalo `$configurator->setProductionMode(FALSE);` (nyní zastaralé).\n\nPokud chcete zapnout vývojový režim jen pro některé počítače, můžete předat metodě seznam IP adres klientů (nikoliv serveru), pro které bude vývojový režim povolen.\n\nPokud tedy Váš počítač má IP adresu například `192.168.1.215`, upravte volání takto:\n\n/--php\n$configurator->setDebugMode(\'192.168.1.215\');\n\\--\n\nVíce IP adres by bylo odděleno čárkou.\n',	'cs',	0,	'public'),
  (102,	0,	'2015-04-24 20:52:18',	'2015-04-24 20:52:18',	3705,	'Single-page microframework',	'single-page-microframework',	'http://forum.nette.org/en/18992-single-page-microframework#p4283',	'en',	0,	'public');

INSERT INTO `article_tag` (`article_id`, `tag_id`) VALUES
  (34,	19),
  (34,	9),
  (34,	27),
  (1,	2),
  (1,	27),
  (3,	19),
  (3,	35),
  (3,	27),
  (4,	36),
  (4,	19),
  (4,	35),
  (4,	27),
  (8,	1),
  (8,	11),
  (8,	27),
  (9,	1),
  (9,	27),
  (10,	3),
  (10,	27),
  (12,	5),
  (12,	9),
  (12,	2),
  (12,	14),
  (12,	27),
  (14,	5),
  (14,	13),
  (14,	14),
  (14,	15),
  (14,	27),
  (15,	1),
  (15,	17),
  (15,	27),
  (16,	9),
  (16,	18),
  (16,	27),
  (17,	9),
  (17,	18),
  (17,	27),
  (19,	5),
  (19,	9),
  (19,	27),
  (20,	19),
  (20,	1),
  (20,	27),
  (21,	5),
  (21,	9),
  (21,	27),
  (23,	5),
  (23,	27),
  (24,	21),
  (24,	6),
  (24,	5),
  (24,	27),
  (26,	21),
  (26,	27),
  (27,	22),
  (27,	37),
  (27,	27),
  (28,	4),
  (28,	23),
  (28,	27),
  (35,	4),
  (35,	27),
  (29,	21),
  (29,	24),
  (29,	27),
  (2,	33),
  (2,	34),
  (2,	27),
  (36,	1),
  (36,	11),
  (36,	27),
  (38,	5),
  (38,	9),
  (38,	2),
  (38,	14),
  (38,	27),
  (18,	5),
  (18,	9),
  (18,	27),
  (22,	5),
  (22,	9),
  (22,	20),
  (22,	27),
  (41,	19),
  (41,	1),
  (41,	27),
  (42,	38),
  (42,	5),
  (42,	6),
  (42,	27),
  (43,	39),
  (43,	27),
  (44,	40),
  (44,	1),
  (44,	12),
  (44,	27),
  (5,	7),
  (5,	8),
  (5,	27),
  (7,	16),
  (7,	9),
  (7,	1),
  (7,	27),
  (40,	7),
  (40,	27),
  (39,	2),
  (39,	27),
  (6,	16),
  (6,	9),
  (6,	1),
  (6,	27),
  (58,	47),
  (58,	48),
  (58,	27),
  (59,	39),
  (59,	45),
  (60,	49),
  (60,	50),
  (60,	19),
  (60,	45),
  (61,	51),
  (61,	45),
  (62,	52),
  (62,	53),
  (62,	54),
  (62,	55),
  (62,	45),
  (63,	52),
  (63,	45),
  (64,	12),
  (64,	27),
  (64,	45),
  (66,	50),
  (66,	57),
  (66,	1),
  (66,	45),
  (67,	50),
  (67,	45),
  (68,	12),
  (68,	27),
  (68,	45),
  (65,	19),
  (65,	56),
  (65,	45),
  (70,	59),
  (70,	45),
  (69,	54),
  (69,	55),
  (69,	9),
  (69,	58),
  (69,	45),
  (71,	19),
  (71,	45),
  (72,	19),
  (72,	45),
  (73,	28),
  (75,	60),
  (75,	11),
  (75,	61),
  (75,	62),
  (75,	63),
  (75,	28),
  (76,	14),
  (76,	64),
  (76,	65),
  (76,	66),
  (76,	45),
  (77,	14),
  (77,	64),
  (77,	65),
  (77,	66),
  (77,	45),
  (78,	19),
  (78,	45),
  (79,	19),
  (79,	45),
  (80,	19),
  (80,	45),
  (81,	19),
  (81,	45),
  (82,	67),
  (82,	68),
  (82,	45),
  (83,	12),
  (83,	45),
  (84,	69),
  (84,	28),
  (85,	70),
  (85,	71),
  (85,	28),
  (86,	28),
  (87,	35),
  (87,	45),
  (88,	44),
  (88,	28),
  (89,	72),
  (89,	73),
  (89,	28),
  (90,	19),
  (90,	28),
  (91,	21),
  (91,	74),
  (91,	45),
  (92,	21),
  (92,	74),
  (92,	45),
  (93,	75),
  (93,	45),
  (94,	75),
  (94,	45),
  (95,	76),
  (95,	77),
  (95,	45),
  (96,	76),
  (96,	77),
  (96,	45),
  (97,	37),
  (97,	45),
  (98,	1),
  (98,	76),
  (98,	78),
  (98,	45),
  (99,	76),
  (99,	16),
  (99,	27),
  (100,	76),
  (100,	46),
  (100,	79),
  (100,	27),
  (101,	76),
  (101,	14),
  (101,	45),
  (57,	14),
  (57,	15),
  (57,	27),
  (74,	60),
  (74,	11),
  (74,	61),
  (74,	62),
  (74,	63),
  (74,	28),
  (102,	80),
  (102,	81),
  (102,	46);

INSERT INTO `tag` (`id`, `name`, `type`) VALUES
  (1,	'latte',	'category'),
  (2,	'dibi',	'category'),
  (3,	'finder',	'normal'),
  (4,	'database',	'normal'),
  (5,	'neon',	'normal'),
  (6,	'configuration',	'normal'),
  (7,	'json',	'normal'),
  (8,	'response',	'normal'),
  (9,	'dependency injection',	'normal'),
  (11,	'javascript',	'normal'),
  (12,	'ajax',	'normal'),
  (13,	'email',	'normal'),
  (14,	'tracy',	'normal'),
  (15,	'debug',	'normal'),
  (16,	'texy',	'normal'),
  (17,	'n:macro',	'normal'),
  (18,	'interface',	'normal'),
  (19,	'form',	'normal'),
  (20,	'SimpleAuthenticator',	'normal'),
  (21,	'routes',	'normal'),
  (22,	'Presenter',	'normal'),
  (23,	'query',	'normal'),
  (24,	'factory',	'normal'),
  (25,	'php',	'normal'),
  (27,	'snippet',	'type'),
  (28,	'tutorial',	'type'),
  (29,	'video',	'type'),
  (31,	'posobota',	'normal'),
  (33,	'tester',	'normal'),
  (34,	'exception',	'normal'),
  (35,	'validation',	'normal'),
  (36,	'image',	'normal'),
  (37,	'persistent',	'normal'),
  (38,	'errorPresenter',	'normal'),
  (39,	'Paginator',	'normal'),
  (40,	'snippets',	'normal'),
  (42,	'facebook',	'normal'),
  (44,	'doctrine',	'normal'),
  (45,	'article',	'type'),
  (46,	'link',	'type'),
  (47,	'kdyby',	'normal'),
  (48,	'translator',	'normal'),
  (49,	'best practice',	'normal'),
  (50,	'components',	'normal'),
  (51,	'cms',	'normal'),
  (52,	'oop',	'normal'),
  (53,	'tdd',	'normal'),
  (54,	'di',	'normal'),
  (55,	'dic',	'normal'),
  (56,	'interaction',	'normal'),
  (57,	'multiplier',	'normal'),
  (58,	'autowire',	'normal'),
  (59,	'composert',	'normal'),
  (60,	'grunt',	'normal'),
  (61,	'css',	'normal'),
  (62,	'minification',	'normal'),
  (63,	'production',	'normal'),
  (64,	'editor',	'normal'),
  (65,	'ide',	'normal'),
  (66,	'browser',	'normal'),
  (67,	'administration',	'normal'),
  (68,	'admin',	'normal'),
  (69,	'blog',	'normal'),
  (70,	'simple',	'normal'),
  (71,	'static',	'normal'),
  (72,	'acl',	'normal'),
  (73,	'access',	'normal'),
  (74,	'router',	'normal'),
  (75,	'TinyMCE',	'normal'),
  (76,	'FAQ',	'category'),
  (77,	'hosting',	'normal'),
  (78,	'escape',	'normal'),
  (79,	'module',	'normal'),
  (80,	'microframework',	'normal'),
  (81,	'single page',	'normal');

INSERT INTO `users` (`id`, `username`, `password`, `email`, `role`, `active`, `name`, `avatar`, `change_email`, `change_email_requested`, `change_email_tokenOne`, `change_email_tokenTwo`) VALUES
  (1639,	'1639',	'',	NULL,	'user',	'1',	'Patrik Votoček',	NULL,	NULL,	NULL,	NULL,	NULL),
  (1657,	'1657',	'',	NULL,	'user',	'1',	'Jan Tvrdík',	NULL,	NULL,	NULL,	NULL,	NULL),
  (1721,	'1721',	'',	NULL,	'user',	'1',	'Panda',	NULL,	NULL,	NULL,	NULL,	NULL),
  (1784,	'1784',	'',	NULL,	'user',	'1',	'Ola',	NULL,	NULL,	NULL,	NULL,	NULL),
  (1860,	'1860',	'',	NULL,	'user',	'1',	'srigi',	NULL,	NULL,	NULL,	NULL,	NULL),
  (1928,	'1928',	'',	NULL,	'user',	'1',	'pekelnik',	NULL,	NULL,	NULL,	NULL,	NULL),
  (2027,	'2027',	'',	NULL,	'user',	'1',	'2bfree',	NULL,	NULL,	NULL,	NULL,	NULL),
  (2118,	'2118',	'',	NULL,	'user',	'1',	'Filip Procházka',	NULL,	NULL,	NULL,	NULL,	NULL),
  (2127,	'2127',	'',	NULL,	'user',	'1',	'newPOPE',	NULL,	NULL,	NULL,	NULL,	NULL),
  (2651,	'2651',	'',	NULL,	'user',	'1',	'22',	NULL,	NULL,	NULL,	NULL,	NULL),
  (2835,	'2835',	'',	NULL,	'user',	'1',	'bene',	NULL,	NULL,	NULL,	NULL,	NULL),
  (3073,	'3073',	'',	NULL,	'user',	'1',	'PJK',	NULL,	NULL,	NULL,	NULL,	NULL),
  (3194,	'3194',	'',	NULL,	'user',	'1',	'Tomáš Votruba',	NULL,	NULL,	NULL,	NULL,	NULL),
  (3328,	'3328',	'',	NULL,	'user',	'1',	'Vojtěch Dobeš',	NULL,	NULL,	NULL,	NULL,	NULL),
  (3363,	'3363',	'',	NULL,	'user',	'1',	'bojovyletoun',	NULL,	NULL,	NULL,	NULL,	NULL),
  (3475,	'3475',	'',	NULL,	'user',	'1',	'Josef Kašpar',	NULL,	NULL,	NULL,	NULL,	NULL),
  (3705,	'chemiX',	'',	NULL,	'user',	'1',	'chemiX',	NULL,	NULL,	NULL,	NULL,	NULL);

-- 2015-06-18 17:09:48